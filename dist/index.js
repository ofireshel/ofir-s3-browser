var h=Object.defineProperty;var c=(o,e)=>h(o,"name",{value:e,configurable:!0});var m={async fetch(o,e){let a=new URL(o.url);if(o.method==="OPTIONS")return new Response(null,{status:200,headers:{"Access-Control-Allow-Origin":"*","Access-Control-Allow-Methods":"GET, POST, PUT, DELETE, OPTIONS","Access-Control-Allow-Headers":"Content-Type, Authorization"}});if(a.pathname==="/lobby"&&o.headers.get("Upgrade")==="websocket"){let s=e.LOBBY.idFromName("main-lobby");return e.LOBBY.get(s).fetch(o)}if(a.pathname.startsWith("/game/")&&o.headers.get("Upgrade")==="websocket"){let s=a.pathname.split("/")[2],t=e.GAMES.idFromName(s);return e.GAMES.get(t).fetch(o)}return new Response("Not Found",{status:404})}},d=class{static{c(this,"PokerLobby")}constructor(e,a){this.state=e,this.env=a,this.players=new Map,this.challenges=new Map}async fetch(e){let a=new WebSocketPair,[s,t]=Object.values(a);t.accept();let n={ws:t,playerId:null,playerName:null};return t.addEventListener("message",async r=>{try{let l=JSON.parse(r.data);await this.handleMessage(n,l)}catch(l){console.error("Error handling message:",l),t.send(JSON.stringify({type:"error",message:"Server error"}))}}),t.addEventListener("close",()=>{this.handleDisconnect(n)}),new Response(null,{status:101,webSocket:s,headers:{"Access-Control-Allow-Origin":"*"}})}async handleMessage(e,a){switch(a.type){case"join":await this.handleJoin(e,a);break;case"challenge":await this.handleChallenge(e,a);break;case"challenge_response":await this.handleChallengeResponse(e,a);break;case"leave":this.handleDisconnect(e);break}}async handleJoin(e,a){let{playerId:s,playerName:t}=a;if(!s||!t||t.length>20){e.ws.send(JSON.stringify({type:"error",message:"Invalid player data"}));return}if(this.players.size>=10){e.ws.send(JSON.stringify({type:"error",message:"Lobby is full"}));return}for(let n of this.players.values())if(n.name===t){e.ws.send(JSON.stringify({type:"error",message:"Name already taken"}));return}e.playerId=s,e.playerName=t,this.players.set(s,{id:s,name:t,status:"available",connection:e}),this.broadcastLobbyUpdate()}async handleChallenge(e,a){let{targetId:s,challengerId:t,challengerName:n}=a,r=this.players.get(s),l=this.players.get(t);if(!r||!l||r.status!=="available"||l.status!=="available"){e.ws.send(JSON.stringify({type:"error",message:"Player not available"}));return}let i=crypto.randomUUID(),y=crypto.randomUUID();this.challenges.set(i,{from:t,to:s,gameId:y,timestamp:Date.now()}),l.status="challenging",r.connection.ws.send(JSON.stringify({type:"challenge_received",from:n,challengeId:i})),this.broadcastLobbyUpdate(),setTimeout(()=>{this.challenges.has(i)&&(this.challenges.delete(i),l.status==="challenging"&&(l.status="available"),this.broadcastLobbyUpdate())},3e4)}async handleChallengeResponse(e,a){let{challengeId:s,response:t}=a,n=this.challenges.get(s);if(!n){e.ws.send(JSON.stringify({type:"error",message:"Challenge not found"}));return}let r=this.players.get(n.from),l=this.players.get(n.to);this.challenges.delete(s),t==="accept"?(this.players.delete(n.from),this.players.delete(n.to),r.connection.ws.send(JSON.stringify({type:"challenge_accepted",gameId:n.gameId,opponent:{id:l.id,name:l.name}})),l.connection.ws.send(JSON.stringify({type:"challenge_accepted",gameId:n.gameId,opponent:{id:r.id,name:r.name}}))):(r.status="available",r.connection.ws.send(JSON.stringify({type:"challenge_declined",from:l.name}))),this.broadcastLobbyUpdate()}handleDisconnect(e){e.playerId&&this.players.has(e.playerId)&&(this.players.delete(e.playerId),this.broadcastLobbyUpdate())}broadcastLobbyUpdate(){let e=Array.from(this.players.values()).map(s=>({id:s.id,name:s.name,status:s.status})),a=JSON.stringify({type:"lobby_update",players:e});for(let s of this.players.values())s.connection.ws.send(a)}},p=class{static{c(this,"PokerGame")}constructor(e,a){this.state=e,this.env=a,this.players=new Map,this.gameState=null}async fetch(e){let a=new WebSocketPair,[s,t]=Object.values(a);t.accept();let n={ws:t,playerId:null,playerName:null};return t.addEventListener("message",async r=>{try{let l=JSON.parse(r.data);await this.handleGameMessage(n,l)}catch(l){console.error("Game error:",l),t.send(JSON.stringify({type:"error",message:"Game error"}))}}),t.addEventListener("close",r=>{console.log(`Game WebSocket closed: code=${r.code}, reason=${r.reason}`),this.handleGameDisconnect(n)}),t.addEventListener("error",r=>{console.log("Game WebSocket error:",r)}),new Response(null,{status:101,webSocket:s,headers:{"Access-Control-Allow-Origin":"*"}})}async handleGameMessage(e,a){switch(a.type){case"join_game":await this.handleJoinGame(e,a);break;case"player_action":await this.handlePlayerAction(e,a);break;case"ping":console.log(`Received ping from ${e.playerName}`),e.ws.send(JSON.stringify({type:"pong",timestamp:Date.now()}));break;default:console.log("Unknown game message type:",a.type)}}async handleJoinGame(e,a){let{playerId:s,playerName:t}=a;console.log(`Player joining game: ${t} (${s})`),e.playerId=s,e.playerName=t,this.players.set(s,{id:s,name:t,connection:e}),console.log(`Game now has ${this.players.size} players`);let n=this.players.size-1;if(e.ws.send(JSON.stringify({type:"game_ready",myPlayerId:n,opponent:this.getOpponentInfo(s),playersConnected:this.players.size})),this.players.size===2){console.log("Both players joined, game ready");let r=0;for(let l of this.players.values())l.connection.ws.send(JSON.stringify({type:"game_ready",myPlayerId:r,opponent:this.getOpponentInfo(l.id),playersConnected:2})),r++}}async handlePlayerAction(e,a){let{action:s}=a;for(let[t,n]of this.players)if(t!==e.playerId){n.connection.ws.send(JSON.stringify({type:"opponent_action",action:s}));break}}handleGameDisconnect(e){if(console.log(`Game disconnect: ${e.playerName} (${e.playerId})`),e.playerId){this.players.delete(e.playerId),console.log(`Player ${e.playerName} removed from game. Remaining players: ${this.players.size}`);for(let a of this.players.values())console.log(`Notifying ${a.name} of disconnect`),a.connection.ws.send(JSON.stringify({type:"game_ended",reason:"Opponent disconnected"}))}}getOpponentInfo(e){for(let[a,s]of this.players)if(a!==e)return{id:a,name:s.name};return null}};export{p as PokerGame,d as PokerLobby,m as default};
//# sourceMappingURL=index.js.map

{
  "version": 3,
  "sources": ["../worker/index.js"],
  "sourceRoot": "dist",
  "sourcesContent": ["// Cloudflare Worker with Durable Objects for multiplayer poker\r\nexport default {\r\n  async fetch(request, env) {\r\n    const url = new URL(request.url);\r\n    \r\n    // Handle CORS\r\n    if (request.method === 'OPTIONS') {\r\n      return new Response(null, {\r\n        status: 200,\r\n        headers: {\r\n          'Access-Control-Allow-Origin': '*',\r\n          'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\r\n          'Access-Control-Allow-Headers': 'Content-Type, Authorization',\r\n        },\r\n      });\r\n    }\r\n    \r\n    // Route WebSocket upgrades to lobby\r\n    if (url.pathname === '/lobby' && request.headers.get('Upgrade') === 'websocket') {\r\n      const lobbyId = env.LOBBY.idFromName('main-lobby');\r\n      const lobby = env.LOBBY.get(lobbyId);\r\n      return lobby.fetch(request);\r\n    }\r\n    \r\n    // Route game WebSocket upgrades\r\n    if (url.pathname.startsWith('/game/') && request.headers.get('Upgrade') === 'websocket') {\r\n      const gameId = url.pathname.split('/')[2];\r\n      const durableGameId = env.GAMES.idFromName(gameId); // Use idFromName instead of idFromString\r\n      const game = env.GAMES.get(durableGameId);\r\n      return game.fetch(request);\r\n    }\r\n    \r\n    return new Response('Not Found', { status: 404 });\r\n  }\r\n};\r\n\r\n// Durable Object for lobby management\r\nexport class PokerLobby {\r\n  constructor(state, env) {\r\n    this.state = state;\r\n    this.env = env;\r\n    this.players = new Map();\r\n    this.challenges = new Map();\r\n  }\r\n  \r\n  async fetch(request) {\r\n    const webSocketPair = new WebSocketPair();\r\n    const [client, server] = Object.values(webSocketPair);\r\n    \r\n    server.accept();\r\n    \r\n    const playerConnection = {\r\n      ws: server,\r\n      playerId: null,\r\n      playerName: null\r\n    };\r\n    \r\n    server.addEventListener('message', async (event) => {\r\n      try {\r\n        const data = JSON.parse(event.data);\r\n        await this.handleMessage(playerConnection, data);\r\n      } catch (error) {\r\n        console.error('Error handling message:', error);\r\n        server.send(JSON.stringify({ type: 'error', message: 'Server error' }));\r\n      }\r\n    });\r\n    \r\n    server.addEventListener('close', () => {\r\n      this.handleDisconnect(playerConnection);\r\n    });\r\n    \r\n    return new Response(null, {\r\n      status: 101,\r\n      webSocket: client,\r\n      headers: {\r\n        'Access-Control-Allow-Origin': '*',\r\n      },\r\n    });\r\n  }\r\n  \r\n  async handleMessage(connection, message) {\r\n    switch (message.type) {\r\n      case 'join':\r\n        await this.handleJoin(connection, message);\r\n        break;\r\n      case 'challenge':\r\n        await this.handleChallenge(connection, message);\r\n        break;\r\n      case 'challenge_response':\r\n        await this.handleChallengeResponse(connection, message);\r\n        break;\r\n      case 'leave':\r\n        this.handleDisconnect(connection);\r\n        break;\r\n    }\r\n  }\r\n  \r\n  async handleJoin(connection, message) {\r\n    const { playerId, playerName } = message;\r\n    \r\n    // Validate input\r\n    if (!playerId || !playerName || playerName.length > 20) {\r\n      connection.ws.send(JSON.stringify({ type: 'error', message: 'Invalid player data' }));\r\n      return;\r\n    }\r\n    \r\n    // Check capacity\r\n    if (this.players.size >= 10) {\r\n      connection.ws.send(JSON.stringify({ type: 'error', message: 'Lobby is full' }));\r\n      return;\r\n    }\r\n    \r\n    // Check name conflicts\r\n    for (const player of this.players.values()) {\r\n      if (player.name === playerName) {\r\n        connection.ws.send(JSON.stringify({ type: 'error', message: 'Name already taken' }));\r\n        return;\r\n      }\r\n    }\r\n    \r\n    connection.playerId = playerId;\r\n    connection.playerName = playerName;\r\n    \r\n    this.players.set(playerId, {\r\n      id: playerId,\r\n      name: playerName,\r\n      status: 'available',\r\n      connection: connection\r\n    });\r\n    \r\n    this.broadcastLobbyUpdate();\r\n  }\r\n  \r\n  async handleChallenge(connection, message) {\r\n    const { targetId, challengerId, challengerName } = message;\r\n    \r\n    const target = this.players.get(targetId);\r\n    const challenger = this.players.get(challengerId);\r\n    \r\n    if (!target || !challenger || target.status !== 'available' || challenger.status !== 'available') {\r\n      connection.ws.send(JSON.stringify({ type: 'error', message: 'Player not available' }));\r\n      return;\r\n    }\r\n    \r\n    const challengeId = crypto.randomUUID();\r\n    const gameId = crypto.randomUUID();\r\n    \r\n    this.challenges.set(challengeId, {\r\n      from: challengerId,\r\n      to: targetId,\r\n      gameId: gameId,\r\n      timestamp: Date.now()\r\n    });\r\n    \r\n    // Only mark challenger as busy, target stays available until they respond\r\n    challenger.status = 'challenging';\r\n    // Don't change target status - they can still receive other challenges\r\n    \r\n    target.connection.ws.send(JSON.stringify({\r\n      type: 'challenge_received',\r\n      from: challengerName,\r\n      challengeId: challengeId\r\n    }));\r\n    \r\n    this.broadcastLobbyUpdate();\r\n    \r\n    // Auto-expire after 30 seconds\r\n    setTimeout(() => {\r\n      if (this.challenges.has(challengeId)) {\r\n        this.challenges.delete(challengeId);\r\n        if (challenger.status === 'challenging') challenger.status = 'available';\r\n        // Target status wasn't changed, so no need to reset it\r\n        this.broadcastLobbyUpdate();\r\n      }\r\n    }, 30000);\r\n  }\r\n  \r\n  async handleChallengeResponse(connection, message) {\r\n    const { challengeId, response } = message;\r\n    \r\n    const challenge = this.challenges.get(challengeId);\r\n    if (!challenge) {\r\n      connection.ws.send(JSON.stringify({ type: 'error', message: 'Challenge not found' }));\r\n      return;\r\n    }\r\n    \r\n    const challenger = this.players.get(challenge.from);\r\n    const target = this.players.get(challenge.to);\r\n    \r\n    this.challenges.delete(challengeId);\r\n    \r\n    if (response === 'accept') {\r\n      // Remove both players from lobby when game starts\r\n      this.players.delete(challenge.from);\r\n      this.players.delete(challenge.to);\r\n      \r\n      // Notify both players with opponent info\r\n      challenger.connection.ws.send(JSON.stringify({\r\n        type: 'challenge_accepted',\r\n        gameId: challenge.gameId,\r\n        opponent: {\r\n          id: target.id,\r\n          name: target.name\r\n        }\r\n      }));\r\n      \r\n      target.connection.ws.send(JSON.stringify({\r\n        type: 'challenge_accepted',\r\n        gameId: challenge.gameId,\r\n        opponent: {\r\n          id: challenger.id,\r\n          name: challenger.name\r\n        }\r\n      }));\r\n    } else {\r\n      // Challenge declined - reset challenger status\r\n      challenger.status = 'available';\r\n      // Target status wasn't changed, so no need to reset it\r\n      \r\n      challenger.connection.ws.send(JSON.stringify({\r\n        type: 'challenge_declined',\r\n        from: target.name\r\n      }));\r\n    }\r\n    \r\n    this.broadcastLobbyUpdate();\r\n  }\r\n  \r\n  handleDisconnect(connection) {\r\n    if (connection.playerId && this.players.has(connection.playerId)) {\r\n      this.players.delete(connection.playerId);\r\n      this.broadcastLobbyUpdate();\r\n    }\r\n  }\r\n  \r\n  broadcastLobbyUpdate() {\r\n    const playerList = Array.from(this.players.values()).map(p => ({\r\n      id: p.id,\r\n      name: p.name,\r\n      status: p.status\r\n    }));\r\n    \r\n    const update = JSON.stringify({\r\n      type: 'lobby_update',\r\n      players: playerList\r\n    });\r\n    \r\n    for (const player of this.players.values()) {\r\n      player.connection.ws.send(update);\r\n    }\r\n  }\r\n}\r\n\r\n// Durable Object for individual poker games\r\nexport class PokerGame {\r\n  constructor(state, env) {\r\n    this.state = state;\r\n    this.env = env;\r\n    this.players = new Map();\r\n    this.gameState = null;\r\n  }\r\n  \r\n  async fetch(request) {\r\n    const webSocketPair = new WebSocketPair();\r\n    const [client, server] = Object.values(webSocketPair);\r\n    \r\n    server.accept();\r\n    \r\n    const playerConnection = {\r\n      ws: server,\r\n      playerId: null,\r\n      playerName: null\r\n    };\r\n    \r\n    server.addEventListener('message', async (event) => {\r\n      try {\r\n        const data = JSON.parse(event.data);\r\n        await this.handleGameMessage(playerConnection, data);\r\n      } catch (error) {\r\n        console.error('Game error:', error);\r\n        server.send(JSON.stringify({ type: 'error', message: 'Game error' }));\r\n      }\r\n    });\r\n    \r\n    server.addEventListener('close', (event) => {\r\n      console.log(`Game WebSocket closed: code=${event.code}, reason=${event.reason}`);\r\n      this.handleGameDisconnect(playerConnection);\r\n    });\r\n    \r\n    server.addEventListener('error', (event) => {\r\n      console.log(`Game WebSocket error:`, event);\r\n    });\r\n    \r\n    return new Response(null, {\r\n      status: 101,\r\n      webSocket: client,\r\n      headers: {\r\n        'Access-Control-Allow-Origin': '*',\r\n      },\r\n    });\r\n  }\r\n  \r\n  async handleGameMessage(connection, message) {\r\n    switch (message.type) {\r\n      case 'join_game':\r\n        await this.handleJoinGame(connection, message);\r\n        break;\r\n      case 'player_action':\r\n        await this.handlePlayerAction(connection, message);\r\n        break;\r\n      case 'ping':\r\n        // Respond to heartbeat ping to keep connection alive\r\n        console.log(`Received ping from ${connection.playerName}`);\r\n        connection.ws.send(JSON.stringify({\r\n          type: 'pong',\r\n          timestamp: Date.now()\r\n        }));\r\n        break;\r\n      default:\r\n        console.log('Unknown game message type:', message.type);\r\n    }\r\n  }\r\n  \r\n  async handleJoinGame(connection, message) {\r\n    const { playerId, playerName } = message;\r\n    \r\n    console.log(`Player joining game: ${playerName} (${playerId})`);\r\n    \r\n    connection.playerId = playerId;\r\n    connection.playerName = playerName;\r\n    \r\n    this.players.set(playerId, {\r\n      id: playerId,\r\n      name: playerName,\r\n      connection: connection\r\n    });\r\n    \r\n    console.log(`Game now has ${this.players.size} players`);\r\n    \r\n    // Assign player IDs: first player is 0, second is 1\r\n    const playerIndex = this.players.size - 1;\r\n    \r\n    // Just send opponent info, let frontend handle game state\r\n    connection.ws.send(JSON.stringify({\r\n      type: 'game_ready',\r\n      myPlayerId: playerIndex,\r\n      opponent: this.getOpponentInfo(playerId),\r\n      playersConnected: this.players.size\r\n    }));\r\n    \r\n    // Notify both players when game is ready\r\n    if (this.players.size === 2) {\r\n      console.log('Both players joined, game ready');\r\n      let index = 0;\r\n      for (const player of this.players.values()) {\r\n        player.connection.ws.send(JSON.stringify({\r\n          type: 'game_ready',\r\n          myPlayerId: index,\r\n          opponent: this.getOpponentInfo(player.id),\r\n          playersConnected: 2\r\n        }));\r\n        index++;\r\n      }\r\n    }\r\n  }\r\n  \r\n  async handlePlayerAction(connection, message) {\r\n    const { action } = message;\r\n    \r\n    // Broadcast action to opponent\r\n    for (const [pid, player] of this.players) {\r\n      if (pid !== connection.playerId) {\r\n        player.connection.ws.send(JSON.stringify({\r\n          type: 'opponent_action',\r\n          action: action\r\n        }));\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  \r\n  handleGameDisconnect(connection) {\r\n    console.log(`Game disconnect: ${connection.playerName} (${connection.playerId})`);\r\n    \r\n    if (connection.playerId) {\r\n      this.players.delete(connection.playerId);\r\n      \r\n      console.log(`Player ${connection.playerName} removed from game. Remaining players: ${this.players.size}`);\r\n      \r\n      // Notify remaining player\r\n      for (const player of this.players.values()) {\r\n        console.log(`Notifying ${player.name} of disconnect`);\r\n        player.connection.ws.send(JSON.stringify({\r\n          type: 'game_ended',\r\n          reason: 'Opponent disconnected'\r\n        }));\r\n      }\r\n    }\r\n  }\r\n  \r\n  getOpponentInfo(playerId) {\r\n    for (const [pid, player] of this.players) {\r\n      if (pid !== playerId) {\r\n        return { id: pid, name: player.name };\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n  \r\n  // Game state is handled entirely by the frontend\r\n  // Worker just relays messages between players\r\n}\r\n"],
  "mappings": "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",
  "names": ["index_default", "request", "env", "url", "lobbyId", "gameId", "durableGameId", "PokerLobby", "__name", "state", "webSocketPair", "client", "server", "playerConnection", "event", "data", "error", "connection", "message", "playerId", "playerName", "player", "targetId", "challengerId", "challengerName", "target", "challenger", "challengeId", "response", "challenge", "playerList", "p", "update", "PokerGame", "playerIndex", "index", "action", "pid"]
}

<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover">
  <title>Heads-Up Poker</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js"></script>
  <style>
    :root {
      --bg1:#0b1220; --bg2:#0f172a; --felt1:#064e3b; --felt2:#052e2a; --felt3:#031a17;
      --line:#10b981; --panel: rgba(14,23,42,0.95); --muted:#93c5fd; --text:#e2e8f0; --accent:#60a5fa; --accent2:#a78bfa;
    }
    html, body { height:100%; margin:0; background:linear-gradient(135deg,var(--bg2),var(--bg1)); color:var(--text); font-family:'Segoe UI', Arial, sans-serif; }
    .wrap { min-height:100%; display:grid; grid-template-rows:auto 1fr auto; }
    header { display:flex; align-items:center; gap:12px; padding:calc(10px + env(safe-area-inset-top)) 16px 12px 16px; background:var(--panel); border-bottom:1px solid #334155; box-shadow:0 2px 8px rgba(0,0,0,.3); }
    header h1 { margin:0; font-size:20px; font-weight:800; background:linear-gradient(45deg,var(--accent),var(--accent2)); -webkit-background-clip:text; background-clip:text; -webkit-text-fill-color:transparent; }
    header .spacer { flex:1; }
    header a { color:var(--muted); text-decoration:none; padding:6px 10px; border:1px solid #475569; border-radius:8px; }
    #stage { position:relative; padding: 10px; }
    #table { width:100%; height: min(78vh, 780px); display:block; border-radius: 14px; background: radial-gradient(120% 120% at 50% 35%, var(--felt1) 0%, var(--felt2) 70%, var(--felt3) 100%); border: 1px solid #065f46; box-shadow: 0 12px 40px rgba(0,0,0,0.35) inset; }
    #glLayer { position:absolute; inset:10px 10px 70px 10px; border-radius:14px; overflow:hidden; pointer-events:none; }
    #glLayer canvas { width:100% !important; height:100% !important; display:block; }
    #hud { position:absolute; left:12px; right:12px; bottom:12px; display:flex; gap:10px; align-items:center; justify-content:center; flex-wrap:wrap; pointer-events:auto; }
    .btn { padding:10px 14px; border-radius:10px; border:2px solid #475569; background:linear-gradient(135deg,#1e293b,#334155); color:var(--text); font-weight:800; cursor:pointer; min-width:84px; }
    .btn:hover { border-color:var(--accent); transform: translateY(-1px); }
    .btn:disabled { opacity:0.4; cursor:not-allowed; }
    .panel { display:flex; align-items:center; gap:8px; padding:8px 10px; border-radius:10px; background:rgba(2,6,23,0.7); border:1px solid #334155; }
    .amt { width:88px; padding:8px 10px; border-radius:10px; border:2px solid #475569; background:#0b1220; color:var(--text); font-weight:700; }
    .chip { padding:4px 10px; border-radius:999px; border:1px solid #334155; background:rgba(15,23,42,.6); color:#cbd5e1; }
    #log { position:absolute; left:50%; transform:translateX(-50%); top:12px; padding:6px 10px; border-radius:10px; background:rgba(2,6,23,0.7); border:1px solid #334155; color:#e2e8f0; font-weight:700; }
    .result { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); padding:18px 22px; border-radius:12px; background:rgba(2,6,23,0.88); border:1px solid #94a3b8; color:#f8fafc; font-weight:900; text-align:center; display:none; z-index:20; box-shadow: 0 20px 80px rgba(0,0,0,0.45); font-size: clamp(18px, 3.2vw, 34px); }
    footer { display:none; }
    .result .res-btn { margin-top:12px; padding:10px 16px; border-radius:10px; border:2px solid #475569; background:linear-gradient(135deg,#1e293b,#334155); color:#e2e8f0; font-weight:800; cursor:pointer; }
    .result .res-btn:hover { border-color:#60a5fa; transform: translateY(-1px); }
      @media (max-width:768px) {
      .amt { width:72px; }
      #table { height: min(68vh, 640px); }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Heads-Up Poker</h1>
      <span id="blinds" class="chip">Blinds: 1/2</span>
      <span class="spacer"></span>
      <a href="games.html">All Games</a>
    </header>
    <div id="stage">
      <canvas id="table"></canvas>
      <div id="glLayer"></div>
      <div id="result" class="result"></div>
      <div id="log" style="display:none"></div>
      <div id="hud">
        <button id="foldBtn" class="btn">Fold</button>
        <button id="checkCallBtn" class="btn">Check</button>
        <div class="panel">
          <button id="halfBtn" class="btn" title="Bet/Raise 1/2 pot">½ Pot</button>
          <button id="potBtn" class="btn" title="Bet/Raise pot">Pot</button>
          <button id="allinBtn" class="btn" title="All-in">All-in</button>
          <input id="betAmt" class="amt" type="number" min="0" step="1" value="2"/>
          <button id="betRaiseBtn" class="btn">Bet</button>
        </div>
      </div>
    </div>
    <footer></footer>
  </div>
  <script>
  (function(){
    'use strict';
    const yrEl = document.getElementById('yr'); if(yrEl) yrEl.textContent = new Date().getFullYear();
    // Canvas setup
    const canvas = document.getElementById('table');
    const ctx = canvas.getContext('2d');
    // WebGL (PixiJS) stage for cards animation
    const glContainer = document.getElementById('glLayer');
    let pixiApp = null;
    let glCards = []; // sprites for animated cards
    // Slightly lower DPR cap for smoother animations on mid devices
    let DPR = Math.min(1.25, window.devicePixelRatio || 1);
    // Offscreen background layer to reduce per-frame cost
    let bgCanvas = document.createElement('canvas');
    let bgCtx = bgCanvas.getContext('2d');
    let bgImage = null; let bgImageLoaded = false; let bgImageLoading = false;
    function resize(){
      const r = canvas.getBoundingClientRect();
      DPR = Math.min(1.25, window.devicePixelRatio || 1);
      canvas.width = Math.max(1, Math.floor(r.width * DPR));
      canvas.height = Math.max(1, Math.floor(r.height * DPR));
      bgCanvas.width = canvas.width;
      bgCanvas.height = canvas.height;
      buildBackground();
      // Setup or resize Pixi
      const w = Math.floor(r.width);
      const h = Math.floor(r.height);
      try{
        if(window.PIXI && PIXI.Application){
          if(!pixiApp){
            pixiApp = new PIXI.Application({ resizeTo: glContainer, antialias:true, backgroundAlpha:0, powerPreference:'high-performance' });
            glContainer.innerHTML=''; glContainer.appendChild(pixiApp.view);
          } else {
            pixiApp.renderer.resize(w, h);
          }
        }
      } catch(e){
        // WebGL not available; continue with canvas-only rendering
        pixiApp = null;
        glContainer.innerHTML='';
      }
      draw();
    }
    window.addEventListener('resize', resize);
    // Player handle
    function getHandle(){
      try {
        let h = localStorage.getItem('poker_handle');
        if(!h){ h = 'Player-' + Math.floor(Math.random()*1e6).toString(36).toUpperCase(); localStorage.setItem('poker_handle', h); }
        return h;
      } catch { return 'Player-' + Math.floor(Math.random()*1e6).toString(36).toUpperCase(); }
    }
    const HUMAN_NAME = getHandle();
    const AI_NAME = 'OrbitBot';

    // Game state
    const SMALL_BLIND = 1, BIG_BLIND = 2, START_STACK = 200;
    // Background portrait image (royalty‑free). Replace URL to customize.
    const TABLE_BG_URL = 'https://images.unsplash.com/photo-1494790108377-be9c29b29330?auto=format&fit=crop&w=2400&q=80';
    const TABLE_BG_OPACITY = 0.18; // 0..1, how visible the photo sits behind the felt
    const state = {
      handId: 0,
      dealer: Math.random() < 0.5 ? 0 : 1, // 0 human, 1 ai
      players: [
        { name: HUMAN_NAME, stack: START_STACK, hole: [], folded:false, isAI:false },
        { name: AI_NAME,    stack: START_STACK, hole: [], folded:false, isAI:true }
      ],
      deck: [], board: [],
      pot: 0,
      street: 'preflop', // preflop, flop, turn, river, showdown
      toAct: 0,
      lastAggressor: -1,
      curBet: 0,
      betThisRound: [0,0],
      actionOpen: true,
      message: '',
      revealed: { human:0, ai:0, board:0 },
      moving: null, // {from:{x,y}, to:{x,y}, start, dur, card, faceUp}
      animating: false,
      acted: [false, false]
    };

    // Deck
    const SUITS = ['♠','♥','♦','♣'];
    function newDeck(){ const d=[]; for(let s=0;s<4;s++){ for(let r=2;r<=14;r++){ d.push({r,s}); } } return d; }
    // Fisher–Yates with crypto fallback for better randomness
    function shuffle(a){
      const rand = (max)=>{
        if(window.crypto && window.crypto.getRandomValues){
          const arr = new Uint32Array(1); window.crypto.getRandomValues(arr); return arr[0] % (max+1);
        }
        return (Math.random()*(max+1))|0;
      };
      for(let i=a.length-1;i>0;i--){ const j=rand(i); [a[i],a[j]]=[a[j],a[i]]; }
    }
    function cardStr(c){ const ranks='--23456789TJQKA'; return ranks[c.r] + SUITS[c.s]; }

    // Hand evaluation (7-card)
    function eval7(cards){
      const bySuit = [[],[],[],[]];
      const counts = new Map();
      let maskRanks=0;
      for(const c of cards){ bySuit[c.s].push(c.r); counts.set(c.r,(counts.get(c.r)||0)+1); maskRanks|=1<<(c.r); }
      for(let s=0;s<4;s++) bySuit[s].sort((a,b)=>b-a);
      const ranks = Array.from(counts.keys()).sort((a,b)=> b-a);
      function bestStraightFromMask(mask){
        if(mask & (1<<14)) mask |= 1<<1;
        for(let hi=14; hi>=5; hi--){ let ok=true; for(let k=0;k<5;k++){ if(!(mask & (1<<(hi-k)))){ ok=false; break; } } if(ok) return hi; }
        return 0;
      }
      let flushSuit=-1; for(let s=0;s<4;s++){ if(bySuit[s].length>=5){ flushSuit=s; break; } }
      if(flushSuit>=0){
        const maskFlush = bySuit[flushSuit].reduce((m,r)=>m|(1<<r),0);
        let hiSF = bestStraightFromMask(maskFlush);
        if(hiSF){
          const rank = 8*1e9 + hiSF*1e6;
          return { rank, cat:8, kickers:[hiSF] };
        }
      }
      const groups = {4:[],3:[],2:[],1:[]};
      for(const r of ranks){ groups[counts.get(r)].push(r); }
      if(groups[4].length){
        const four=groups[4][0]; const rest=ranks.filter(x=>x!==four);
        return { rank: 7*1e9 + four*1e6 + (rest[0]||0)*1e3, cat:7, kickers:[four,rest[0]||0] };
      }
      if(groups[3].length){
        if(groups[3].length>=2 || groups[2].length){
          const trips = groups[3][0];
          const pair = groups[3].length>=2 ? groups[3][1] : groups[2][0];
          return { rank: 6*1e9 + trips*1e6 + pair*1e3, cat:6, kickers:[trips,pair] };
        }
      }
      if(flushSuit>=0){
        const top5 = bySuit[flushSuit].slice(0,5);
        return { rank: 5*1e9 + top5[0]*1e6 + top5[1]*1e4 + top5[2]*1e2 + top5[3], cat:5, kickers: top5 };
      }
      const hiSt = bestStraightFromMask(maskRanks);
      if(hiSt){ return { rank: 4*1e9 + hiSt*1e6, cat:4, kickers:[hiSt] }; }
      if(groups[3].length){
        const t=groups[3][0]; const rest=ranks.filter(x=>x!==t); return { rank: 3*1e9 + t*1e6 + (rest[0]||0)*1e4 + (rest[1]||0)*1e2, cat:3, kickers:[t, rest[0]||0, rest[1]||0] };
      }
      if(groups[2].length>=2){
        const [p1,p2]=groups[2].slice(0,2); const rest=ranks.filter(x=>x!==p1&&x!==p2);
        return { rank: 2*1e9 + p1*1e6 + p2*1e4 + (rest[0]||0)*1e2, cat:2, kickers:[p1,p2, rest[0]||0] };
      }
      if(groups[2].length===1){
        const p=groups[2][0]; const rest=ranks.filter(x=>x!==p);
        return { rank: 1*1e9 + p*1e6 + (rest[0]||0)*1e4 + (rest[1]||0)*1e2 + (rest[2]||0), cat:1, kickers:[p, rest[0]||0, rest[1]||0, rest[2]||0] };
      }
      const top5 = ranks.slice(0,5); while(top5.length<5) top5.push(0);
      return { rank: top5[0]*1e6 + top5[1]*1e4 + top5[2]*1e2 + top5[3]*1, cat:0, kickers: top5 };
    }
    function compareHands(a,b){ return a.rank===b.rank ? 0 : (a.rank>b.rank?1:-1); }
    function handLabel(h){
      const names=['High Card','Pair','Two Pair','Three of a Kind','Straight','Flush','Full House','Four of a Kind','Straight Flush'];
      return names[h.cat] || 'Hand';
    }

    // Monte Carlo equity estimation vs 1 opponent
    function estimateEquity(hole, board, dead, iters){
      const used = new Set(dead.map(cardStr));
      hole.forEach(c=>used.add(cardStr(c)));
      board.forEach(c=>used.add(cardStr(c)));
      const deck = []; for(let s=0;s<4;s++) for(let r=2;r<=14;r++){ const c={r,s}; if(!used.has(cardStr(c))) deck.push(c);} 
      let wins=0, ties=0;
      const needBoard = 5 - board.length;
      for(let i=0;i<iters;i++){
        const a = (Math.random()*deck.length)|0; const c1=deck[a];
        const b = (Math.random()*(deck.length-1)|0); const c2=deck[b>=a?b+1:b];
        const rem = deck.filter((c,idx)=> idx!==a && idx!==(b>=a?b+1:b));
        const run=[]; for(let k=0;k<needBoard;k++){ const j=(Math.random()*rem.length)|0; run.push(rem.splice(j,1)[0]); }
        const myEval = eval7(hole.concat(board, run));
        const oppEval = eval7([c1,c2].concat(board, run));
        const cmp = compareHands(myEval, oppEval);
        if(cmp>0) wins++; else if(cmp===0) ties++;
      }
      return (wins + ties*0.5) / Math.max(1,iters);
    }

    // Rendering helpers
    function buildBackground(){
      const w=bgCanvas.width, h=bgCanvas.height; const bctx=bgCtx;
      bctx.setTransform(1,0,0,1,0,0); bctx.clearRect(0,0,w,h);
      // Background portrait image layer (soft)
      if(!bgImageLoaded && !bgImageLoading){
        bgImageLoading = true; bgImage = new Image(); bgImage.crossOrigin='anonymous'; bgImage.onload=()=>{ bgImageLoaded=true; buildBackground(); }; bgImage.onerror=()=>{ bgImageLoaded=false; }; bgImage.src = TABLE_BG_URL;
      }
      if(bgImageLoaded){
        const iw=bgImage.naturalWidth, ih=bgImage.naturalHeight;
        // cover
        const scale = Math.max(w/iw, h/ih);
        const dw = iw*scale, dh = ih*scale;
        bctx.save(); bctx.globalAlpha = TABLE_BG_OPACITY; bctx.drawImage(bgImage, (w-dw)/2, (h-dh)/2, dw, dh); bctx.restore();
      }
      // Static felt gradient
      const bgGrad = bctx.createLinearGradient(0,0,0,h);
      bgGrad.addColorStop(0,'#064e3b'); bgGrad.addColorStop(1,'#052e2a');
      bctx.fillStyle=bgGrad; bctx.fillRect(0,0,w,h);
      // Table shape
      bctx.save(); bctx.translate(w/2, h/2); const R=Math.min(w,h)*0.42; const r=R*0.35;
      bctx.fillStyle='#065f46'; bctx.strokeStyle= getGradient('#10b981','#34d399'); bctx.lineWidth=8*DPR;
      roundTablePath.call({ctx:bctx}, R, r);
      // Emulate roundTablePath using bctx
      function path(Rr, rr){ bctx.beginPath(); bctx.moveTo(-Rr, -rr); bctx.lineTo(Rr, -rr); bctx.arc(Rr,0,rr,-Math.PI/2,Math.PI/2); bctx.lineTo(-Rr, r); bctx.arc(-Rr,0,rr,Math.PI/2,-Math.PI/2); bctx.closePath(); }
      // Draw using normal helper
      bctx.beginPath(); bctx.moveTo(-R, -r); bctx.lineTo(R, -r); bctx.arc(R,0,r,-Math.PI/2,Math.PI/2); bctx.lineTo(-R, r); bctx.arc(-R,0,r,Math.PI/2,-Math.PI/2); bctx.closePath();
      bctx.fill(); bctx.stroke();
      // Static soft vignette
      const g=bctx.createRadialGradient(w/2,h*0.35,Math.min(w,h)*0.05, w/2,h*0.35, Math.max(w,h)*0.7);
      g.addColorStop(0,'rgba(16,185,129,0.12)'); g.addColorStop(1,'rgba(16,185,129,0)');
      bctx.fillStyle=g; bctx.fillRect(0,0,w,h);
      bctx.restore();
    }

    function drawTable(){
      const w=canvas.width, h=canvas.height; ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,w,h);
      ctx.drawImage(bgCanvas, 0, 0);
    }
    function getGradient(a,b){ const g=ctx.createLinearGradient(0,0,0,canvas.height); g.addColorStop(0,a); g.addColorStop(1,b); return g; }
    function roundTablePath(R,r){ ctx.beginPath(); ctx.moveTo(-R, -r); ctx.lineTo(R, -r); ctx.arc(R,0,r,-Math.PI/2,Math.PI/2); ctx.lineTo(-R, r); ctx.arc(-R,0,r,Math.PI/2,-Math.PI/2); ctx.closePath(); }
    function drawChipStack(x,y,amount){ ctx.save(); ctx.translate(x,y); const chips=Math.min(8, Math.max(1, Math.round(amount/5))); for(let i=0;i<chips;i++){ ctx.fillStyle='rgba(236,72,153,'+(0.4+0.05*i)+')'; ctx.beginPath(); ctx.ellipse(0, -i*3*DPR, 16*DPR, 6*DPR, 0,0,Math.PI*2); ctx.fill(); } ctx.fillStyle='#fbbf24'; ctx.font = `${12*DPR}px Segoe UI`; ctx.textAlign='center'; ctx.textBaseline='bottom'; ctx.fillText(amount.toString(), 0, -chips*3*DPR-2*DPR); ctx.restore(); }
    function drawDealerButton(x,y){ ctx.save(); ctx.translate(x,y); ctx.fillStyle='#e5e7eb'; ctx.strokeStyle='#111827'; ctx.lineWidth=2*DPR; ctx.beginPath(); ctx.arc(0,0, 10*DPR, 0, Math.PI*2); ctx.fill(); ctx.stroke(); ctx.fillStyle='#111827'; ctx.font = `${10*DPR}px Arial Black`; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('D',0,1); ctx.restore(); }
    function suitColor(s){ return (s===1||s===2)?'#ef4444':'#111827'; }
    function rankStr(r){
      if(r===10) return '10';
      return '--23456789TJQKA'[r];
    }
    const SUIT_EMO = ['♠','♥','♦','♣'];
    function drawCard(x,y,card,faceUp=true){
      const w=81*DPR, h=116*DPR, r=12*DPR; ctx.save(); ctx.translate(x,y); ctx.shadowColor='rgba(0,0,0,0.45)'; ctx.shadowBlur=11*DPR; roundedRect(-w/2,-h/2,w,h,r);
      if(faceUp){
        // classic card face
        ctx.fillStyle='#ffffff'; ctx.strokeStyle='#b6c2cf'; ctx.lineWidth=2.2*DPR; ctx.fill(); ctx.stroke();
        // subtle inner border
        roundedRect(-w/2+4*DPR,-h/2+4*DPR,w-8*DPR,h-8*DPR,r*0.8); ctx.strokeStyle='#e2e8f0'; ctx.lineWidth=1.2*DPR; ctx.stroke();
        // corners and center pip
        ctx.fillStyle=suitColor(card.s); ctx.textAlign='left'; ctx.textBaseline='top';
        ctx.font = `${22*DPR}px Arial Black`; ctx.fillText(rankStr(card.r), -w/2+9*DPR, -h/2+7*DPR);
        ctx.font = `${22*DPR}px Segoe UI Emoji`; ctx.fillText(SUIT_EMO[card.s], -w/2+9*DPR, -h/2+32*DPR);
        ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font = `${49*DPR}px Segoe UI Emoji`; ctx.fillText(SUIT_EMO[card.s], 0, 10*DPR);
      } else {
        // classic blue back with bordered lattice pattern
        ctx.fillStyle='#114b8b'; ctx.strokeStyle='#0b3561'; ctx.lineWidth=2.4*DPR; ctx.fill(); ctx.stroke();
        // bordered lattice
        ctx.save();
        roundedRect(-w/2+8*DPR,-h/2+8*DPR,w-16*DPR,h-16*DPR,r*0.5); ctx.strokeStyle='#e5e7eb'; ctx.lineWidth=1.6*DPR; ctx.stroke();
        ctx.beginPath(); roundedRect(-w/2+10*DPR,-h/2+10*DPR,w-20*DPR,h-20*DPR,r*0.4); ctx.clip();
        ctx.globalAlpha=0.35; ctx.strokeStyle='#cfe3ff'; ctx.lineWidth=1*DPR;
        for(let y=-h/2; y<h/2; y+=9*DPR){ ctx.beginPath(); ctx.moveTo(-w/2,y); ctx.lineTo(w/2,y+ w); ctx.stroke(); }
        for(let y=-h/2; y<h/2; y+=9*DPR){ ctx.beginPath(); ctx.moveTo(w/2,y); ctx.lineTo(-w/2,y+ w); ctx.stroke(); }
        ctx.restore(); ctx.globalAlpha=1;
      }
      ctx.restore();
    }
    // WebGL fly card using PixiJS for ultra smooth animation
    function flyCard(from, to, card, faceUp, durMs, onDone){
      try{
        const w=60, h=86, r=9;
        const gfx = new PIXI.Graphics();
        gfx.beginFill(0xf8fafc); gfx.lineStyle(2, 0xcbd5e1, 1); gfx.drawRoundedRect(-w/2, -h/2, w, h, r); gfx.endFill();
        // suit & rank
        if(faceUp){
          const suitColors=[0x111827,0xef4444,0xef4444,0x111827];
          const rankText = new PIXI.Text(rankStr(card.r), {fontFamily:'Arial Black', fontSize:14, fill:suitColors[card.s]});
          rankText.anchor.set(0,0); rankText.position.set(-w/2+8,-h/2+6);
          const suitText = new PIXI.Text(SUIT_EMO[card.s], {fontFamily:'Segoe UI Emoji', fontSize:14, fill:suitColors[card.s]});
          suitText.anchor.set(0,0); suitText.position.set(-w/2+8,-h/2+24);
          const centerSuit = new PIXI.Text(SUIT_EMO[card.s], {fontFamily:'Segoe UI Emoji', fontSize:30, fill:suitColors[card.s]});
          centerSuit.anchor.set(0.5,0.5); centerSuit.position.set(0,8);
          gfx.addChild(rankText); gfx.addChild(suitText); gfx.addChild(centerSuit);
        } else {
          const g = new PIXI.Graphics(); g.beginFill(0x1d4ed8); g.drawRoundedRect(-w/2,-h/2,w,h,r); g.endFill();
          gfx.addChild(g);
        }
        const sprite = new PIXI.Container(); sprite.addChild(gfx);
        // map logical coords to pixi coords
        const rect = canvas.getBoundingClientRect();
        const px = (valX,valY)=> [valX / DPR, valY / DPR]; // canvas coords -> CSS pixels
        const [sx,sy] = px(from.x, from.y);
        sprite.position.set(sx, sy);
        pixiApp.stage.addChild(sprite);
        const start=performance.now(), D=durMs;
        function tick(){
          const t=Math.min(1, (performance.now()-start)/D);
          const ease = t*t*(3-2*t);
          const [nx,ny] = px(from.x + (to.x-from.x)*ease, from.y + (to.y-from.y)*ease);
          sprite.position.set(nx, ny);
          if(t<1){ requestAnimationFrame(tick); }
          else { pixiApp.stage.removeChild(sprite); if(onDone) onDone(); }
        }
        requestAnimationFrame(tick);
      }catch(e){
        // Fallback to canvas-based moving if WebGL fails
        state.moving = { from, to, start: performance.now(), dur: durMs, card, faceUp, onDone };
        requestAnimationFrame(draw);
      }
    }
    function roundedRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
    function positions(){
      const w=canvas.width, h=canvas.height; const cx=w/2, cy=h/2; const boardY = cy - 14*DPR; const gap = 96*DPR;
      return {
        board: [
          [cx-2*gap, boardY],
          [cx-gap,   boardY],
          [cx,       boardY],
          [cx+gap,   boardY],
          [cx+2*gap, boardY]
        ],
        pot: [cx, cy - 56*DPR],
        human: { name:[cx, h-28*DPR], cards:[cx-45*DPR, h-130*DPR, cx+45*DPR, h-130*DPR], chips:[cx+150*DPR, h-135*DPR] },
        ai:    { name:[cx, 22*DPR],   cards:[cx-45*DPR, 130*DPR,    cx+45*DPR, 130*DPR],    chips:[cx+180*DPR, 60*DPR] }
      };
    }
    function draw(){
      drawTable();
      const p=positions();
      ctx.fillStyle='#e2e8f0'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.font = `${14*DPR}px Segoe UI`;
      ctx.fillText(`${state.players[0].name}`, p.human.name[0], p.human.name[1]);
      ctx.fillText(`${state.players[1].name}`, p.ai.name[0], p.ai.name[1]);
      // Big chip stacks below names
      ctx.font = `${34*DPR}px Arial Black`;
      ctx.fillStyle = '#e2e8f0';
      ctx.fillText(`${state.players[0].stack} chips`, p.human.name[0], p.human.name[1]+18*DPR);
      ctx.fillText(`${state.players[1].stack} chips`, p.ai.name[0], p.ai.name[1]+18*DPR);
      const dpos = state.dealer===0? [p.human.cards[0]-36*DPR, p.human.cards[1]+20*DPR] : [p.ai.cards[0]-36*DPR, p.ai.cards[1]-20*DPR];
      drawDealerButton(dpos[0], dpos[1]);
      ctx.fillStyle='#fbbf24'; ctx.font = `${18*DPR}px Arial Black`; ctx.fillText(`Pot: ${state.pot}`, p.pot[0], p.pot[1]);
      for(let i=0;i<5;i++){
        const [x,y]=p.board[i]; const c=state.board[i];
        const show = i < state.revealed.board;
        drawCard(x,y, c||{r:14,s:0}, show);
      }
      drawChipStack(p.human.cards[0]+150*DPR, p.human.cards[1], state.betThisRound[0]||0);
      drawChipStack(p.ai.cards[0]+150*DPR, p.ai.cards[1], state.betThisRound[1]||0);
      const h0 = state.players[0].hole, h1 = state.players[1].hole;
      if(state.revealed.human>=1 && h0[0]) drawCard(p.human.cards[0], p.human.cards[1], h0[0], true);
      if(state.revealed.human>=2 && h0[1]) drawCard(p.human.cards[2], p.human.cards[3], h0[1], true);
      if(state.revealed.ai>=1 && h1[0])    drawCard(p.ai.cards[0],    p.ai.cards[1],    h1[0], state.street==='showdown');
      if(state.revealed.ai>=2 && h1[1])    drawCard(p.ai.cards[2],    p.ai.cards[3],    h1[1], state.street==='showdown');
      // moving card on top
      if(state.moving){
        const m=state.moving; const now=performance.now();
        const t=Math.min(1,(now-m.start)/m.dur);
        // Use smoothstep easing for stable, non-choppy animation on all devices
        const ease = t * t * (3 - 2 * t);
        const x=m.from.x + (m.to.x-m.from.x)*ease; const y=m.from.y + (m.to.y-m.from.y)*ease;
        drawCard(x,y, m.card, m.faceUp);
        if(t>=1){ state.moving=null; if(m.onDone) m.onDone(); }
      }
      if(state.animating || state.moving) requestAnimationFrame(draw);
    }

    // Betting logic
    function resetHand(){
      state.handId++; state.board=[]; state.pot=0; state.street='preflop'; state.curBet=0; state.betThisRound=[0,0]; state.players.forEach(p=>{p.hole=[]; p.folded=false;}); state.lastAggressor=-1; state.message='';
      state.dealer = 1 - state.dealer;
      state.deck = newDeck(); shuffle(state.deck);
      postBlind(state.dealer, SMALL_BLIND);
      postBlind(1-state.dealer, BIG_BLIND);
      for(let i=0;i<2;i++){
        state.players[state.dealer].hole.push(state.deck.pop());
        state.players[1-state.dealer].hole.push(state.deck.pop());
      }
      state.revealed = { human:0, ai:0, board:0 };
      state.toAct = state.dealer;
      state.animating = true;
      updateControls();
      state.animating=true; draw();
      // Ensure canvas has dimensions before animation
      if(canvas.width<10 || canvas.height<10){ setTimeout(startDealAnimation, 50); } else { startDealAnimation(); }
    }
    function postBlind(pid, amt){ const p=state.players[pid]; const pay=Math.min(amt, p.stack); p.stack-=pay; state.betThisRound[pid]+=pay; state.pot+=pay; state.curBet=Math.max(state.curBet, state.betThisRound[pid]); }
    function minRaise(){ const highest=Math.max(state.betThisRound[0], state.betThisRound[1]); const other=Math.min(state.betThisRound[0], state.betThisRound[1]); const lastRaise=Math.max(BIG_BLIND, highest-other); return highest + lastRaise; }
    function canCheck(pid){ return state.betThisRound[pid]===state.curBet; }
    function toCall(pid){ return Math.max(0, state.curBet - state.betThisRound[pid]); }
    function allInCap(pid){ return state.players[pid].stack + state.betThisRound[pid]; }
    function openAmountRange(pid){
      const min = state.curBet===0 ? BIG_BLIND : minRaise();
      // Cap by effective stacks (cannot bet more than opponent can ever call)
      const effectiveMax = Math.min(allInCap(pid), allInCap(1-pid));
      const max = Math.max(0, effectiveMax);
      return [Math.min(min,max), max];
    }
    function nextPlayerAfter(pid){ return 1-pid; }
    function bothActedAndEqual(){
      // End the street when there is a bet (curBet>0), both have acted this street,
      // and their committed amounts are equal (i.e., a bet was called). If all-in+equal, auto-runout will handle.
      if(isAllInAndEqual()) return false;
      return state.curBet>0 && state.betThisRound[0]===state.betThisRound[1] && state.acted[0] && state.acted[1];
    }
    function bothCheckedThisStreet(){ return state.curBet===0 && state.acted[0] && state.acted[1]; }
    function endStreet(){
      state.street = state.street==='preflop'? 'flop' : state.street==='flop'? 'turn' : state.street==='turn'? 'river' : 'showdown';
      state.curBet=0; state.betThisRound=[0,0]; state.lastAggressor=-1; state.acted=[false,false]; state.toAct = state.dealer===1? 0 : 1;
      if(state.street==='flop'){ state.board.push(state.deck.pop(), state.deck.pop(), state.deck.pop()); }
      else if(state.street==='turn' || state.street==='river'){ state.board.push(state.deck.pop()); }
      if(state.street==='showdown') { doShowdown(); return; }
      if(state.street==='flop'){ state.revealed.board = Math.max(state.revealed.board, 3); }
      if(state.street==='turn'){ state.revealed.board = Math.max(state.revealed.board, 4); }
      if(state.street==='river'){ state.revealed.board = Math.max(state.revealed.board, 5); }
      updateControls(); draw(); if(!maybeAutoRunout()) maybeAIMove();
    }

    function isAllInAndEqual(){
      return (state.players[0].stack===0 || state.players[1].stack===0) && state.betThisRound[0]===state.betThisRound[1];
    }

    // Auto-deal remaining community cards when players are all-in and bets are matched
    function maybeAutoRunout(){
      if(state.street==='showdown') return false;
      if(!isAllInAndEqual()) return false;

      // Figure out how many board cards remain to reach the river
      const startIdx = Math.max(0, Math.min(5, state.board.length));
      const remaining = 5 - startIdx;
      if(remaining<=0){
        // Already have full board, go to showdown
        doShowdown();
        return true;
      }

      const p=positions();
      const deckPos = { x: canvas.width/2 + 220*DPR, y: canvas.height/2 - 40*DPR };
      state.animating = true; updateControls();
      const queue = [];
      for(let i=0;i<remaining;i++){
        const idx = startIdx + i;
        if(state.board.length<=idx){ state.board.push(state.deck.pop()); }
        queue.push({ idx, card: state.board[idx], to: { x: p.board[idx][0], y: p.board[idx][1] } });
      }
      function animateNext(){
        if(queue.length===0){ state.animating=false; updateControls(); doShowdown(); return; }
        const item = queue.shift();
        if(pixiApp){
          flyCard(deckPos, item.to, item.card, true, 100, ()=>{
            state.revealed.board = Math.max(state.revealed.board, item.idx+1);
            animateNext();
          });
        } else {
          state.moving = { from: deckPos, to: item.to, start: performance.now(), dur: 120, card: item.card, faceUp: true, onDone: ()=>{
            state.revealed.board = Math.max(state.revealed.board, item.idx+1);
            animateNext();
          }};
          requestAnimationFrame(draw);
        }
      }
      animateNext();
      return true;
    }

    // Dealing animation (hole cards then immediate flop exposed)
    function startDealAnimation(){
      const p=positions();
      const deckPos = { x: canvas.width/2 + 220*DPR, y: canvas.height/2 - 40*DPR };
      const seq = [
        { who:'human', idx:0, to:{x:p.human.cards[0], y:p.human.cards[1]}, faceUp:true },
        { who:'ai',    idx:0, to:{x:p.ai.cards[0],    y:p.ai.cards[1]},    faceUp:false },
        { who:'human', idx:1, to:{x:p.human.cards[2], y:p.human.cards[3]}, faceUp:true },
        { who:'ai',    idx:1, to:{x:p.ai.cards[2],    y:p.ai.cards[3]},    faceUp:false },
        { who:'board', idx:0, to:{x:p.board[0][0],    y:p.board[0][1]},    faceUp:true },
        { who:'board', idx:1, to:{x:p.board[1][0],    y:p.board[1][1]},    faceUp:true },
        { who:'board', idx:2, to:{x:p.board[2][0],    y:p.board[2][1]},    faceUp:true }
      ];
      let i=0;
      let progressed=false;
      function step(){
        if(i>=seq.length){
          // Move to flop street and enable action
          state.street='flop';
      state.curBet=0; state.betThisRound=[0,0]; state.lastAggressor=-1; state.acted=[false,false]; state.toAct = (state.dealer===1? 0 : 1);
          // Ensure board has 3 cards
          while(state.board.length<3){ state.board.push(state.deck.pop()); }
          state.animating=false; updateControls(); draw(); if(!maybeAutoRunout()) maybeAIMove();
          return;
        }
        const s=seq[i++];
        // Ensure target card exists in state (for board we push on reveal)
        if(s.who==='board' && state.board.length<=s.idx){ state.board.push(state.deck.pop()); }
        const card = s.who==='human' ? state.players[0].hole[s.idx] : s.who==='ai' ? state.players[1].hole[s.idx] : state.board[s.idx];
        // WebGL sprite for the card fly animation (fallbacks to canvas if WebGL missing)
        if(pixiApp){
          flyCard(deckPos, s.to, card, s.faceUp, 120, ()=>{
            if(s.who==='human'){ state.revealed.human = Math.max(state.revealed.human, s.idx+1); }
            else if(s.who==='ai'){ state.revealed.ai = Math.max(state.revealed.ai, s.idx+1); }
            else { state.revealed.board = Math.max(state.revealed.board, s.idx+1); }
            progressed=true; draw(); setTimeout(step, 10);
          });
        } else {
          state.moving = { from: deckPos, to: s.to, start: performance.now(), dur: 160, card, faceUp: s.faceUp, onDone: ()=>{
            if(s.who==='human'){ state.revealed.human = Math.max(state.revealed.human, s.idx+1); }
            else if(s.who==='ai'){ state.revealed.ai = Math.max(state.revealed.ai, s.idx+1); }
            else { state.revealed.board = Math.max(state.revealed.board, s.idx+1); }
            progressed=true; draw(); setTimeout(step, 10);
          }};
          requestAnimationFrame(draw);
        }
      }
      step();
      // Watchdog: force reveal if animation fails
      setTimeout(()=>{
        if(!progressed){
          state.revealed.human=2; state.revealed.ai=0; // keep AI hidden pre-showdown
          while(state.board.length<3){ state.board.push(state.deck.pop()); }
          state.revealed.board=3; state.animating=false; draw(); updateControls(); if(!maybeAutoRunout()) maybeAIMove();
        }
      }, 1200);
    }
    function doShowdown(){
      // Ensure we are in showdown state and everything is revealed properly
      state.street = 'showdown';
      state.revealed.board = Math.max(state.revealed.board, 5);
      state.revealed.ai = 2;
      const alive = [0,1].filter(i=>!state.players[i].folded);
      const scores = alive.map(i=>({ i, hand: eval7(state.players[i].hole.concat(state.board)) }));
      let best = scores[0]; for(const s of scores){ if(compareHands(s.hand, best.hand)>0) best=s; }
      const winners = scores.filter(s=>compareHands(s.hand, best.hand)===0).map(s=>s.i);
      const prizeEach = Math.floor(state.pot / winners.length);
      winners.forEach(i=> state.players[i].stack += prizeEach);
      const loser = alive.find(i=> !winners.includes(i));
      const winnerName = winners.length===2 ? 'Both players' : state.players[winners[0]].name;
      const bestLabel = handLabel(eval7(state.players[winners[0]].hole.concat(state.board)));
      const oppLabel = loser!=null ? handLabel(eval7(state.players[loser].hole.concat(state.board))) : '';
      const resultEl = document.getElementById('result');
      const contId = 'res-continue';
      resultEl.style.display='block';
      resultEl.innerHTML = (winners.length===2
        ? `Split Pot — ${bestLabel}`
        : `${winnerName} wins ${state.pot} with ${bestLabel}` + (loser!=null? `<br/><span style='font-weight:700;color:#93c5fd'>Beats ${state.players[loser].name}'s ${oppLabel}</span>` : ''))
        + `<div><button id="${contId}" class="res-btn">Continue</button></div>`;
      state.message = winners.length===2 ? 'Split Pot' : `${state.players[best.i].name} wins ${state.pot}`;
      state.pot=0; updateControls(); draw();
      let advanced=false; const proceed=()=>{
        if(advanced) return; advanced=true; resultEl.style.display='none';
        if(state.players[0].stack<=0 || state.players[1].stack<=0){ showLog('Game Over'); }
        else resetHand();
      };
      const btn=document.getElementById(contId); if(btn) btn.onclick=proceed;
      setTimeout(()=>{ proceed(); }, 5000);
    }
    function playerFold(pid){ state.players[pid].folded=true; const opp=1-pid; state.players[opp].stack += state.pot; state.message=`${state.players[opp].name} wins ${state.pot}`; state.pot=0; state.street='showdown'; showLog(state.message); updateControls(); draw(); setTimeout(()=>resetHand(), 1400); }
    function playerCall(pid){
      const need=toCall(pid); const p=state.players[pid]; const pay=Math.min(need, p.stack);
      p.stack-=pay; state.betThisRound[pid]+=pay; state.pot+=pay;
      state.acted[pid] = true;
      // If an all-in has been called and bets are matched, immediately run out the board
      if(isAllInAndEqual()) { updateControls(); draw(); maybeAutoRunout(); return; }
      if(bothActedAndEqual()) { endStreet(); }
      else { state.toAct=nextPlayerAfter(pid); updateControls(); draw(); if(!maybeAutoRunout()) maybeAIMove(); }
    }
    function playerBetOrRaise(pid, amount){
      const [minAmt, maxAmt]=openAmountRange(pid);
      const target = Math.max(minAmt, Math.min(amount, maxAmt));
      const p=state.players[pid]; const put = target - state.betThisRound[pid];
      const pay = Math.min(put, p.stack);
      p.stack-=pay; state.pot+=pay; state.betThisRound[pid]+=pay;
      state.curBet=Math.max(state.curBet, state.betThisRound[pid]);
      state.lastAggressor=pid; state.acted=[false,false]; state.acted[pid]=true; state.toAct=nextPlayerAfter(pid);
      // If this action results in all-in and matched bets, run out immediately
      if(isAllInAndEqual()) { updateControls(); draw(); maybeAutoRunout(); return; }
      // If opponent has zero stack (covered and called), runout
      if(state.players[1-pid].stack===0 && state.betThisRound[0]===state.betThisRound[1]){ updateControls(); draw(); maybeAutoRunout(); return; }
      updateControls(); draw(); if(!maybeAutoRunout()) maybeAIMove();
    }

    // Controls
    const foldBtn = document.getElementById('foldBtn');
    const checkCallBtn = document.getElementById('checkCallBtn');
    const halfBtn = document.getElementById('halfBtn');
    const potBtn = document.getElementById('potBtn');
    const allinBtn = document.getElementById('allinBtn');
    const betAmt = document.getElementById('betAmt');
    const betRaiseBtn = document.getElementById('betRaiseBtn');
    function showLog(msg){ const el=document.getElementById('log'); el.textContent=msg; el.style.display='block'; clearTimeout(showLog._t); showLog._t=setTimeout(()=>{ el.style.display='none'; }, 2200); }
    function updateControls(){
      const pid=0; const meTurn = state.toAct===pid && !state.players[pid].folded && state.street!=='showdown' && !state.animating;
      const callable = toCall(pid);
      const disableAll = state.animating || state.street==='showdown';
      foldBtn.disabled = disableAll || !meTurn;
      checkCallBtn.textContent = callable>0 ? `Call ${callable}` : 'Check';
      checkCallBtn.disabled = disableAll || !meTurn;
      const [minAmt,maxAmt] = openAmountRange(pid);
      betAmt.value = Math.min(Math.max(Number(betAmt.value)||minAmt, minAmt), maxAmt);
      halfBtn.disabled = disableAll || !meTurn; potBtn.disabled = disableAll || !meTurn; allinBtn.disabled = disableAll || !meTurn; betRaiseBtn.disabled = disableAll || !meTurn;
      betRaiseBtn.textContent = state.curBet>0? 'Raise' : 'Bet';
    }
    foldBtn.addEventListener('click', ()=>{ if(state.toAct!==0) return; playerFold(0); });
    checkCallBtn.addEventListener('click', ()=>{ if(state.toAct!==0) return; const need=toCall(0); if(need>0) playerCall(0); else { state.acted[0]=true; if(bothCheckedThisStreet()) endStreet(); else { state.toAct=1; updateControls(); draw(); maybeAIMove(); } }});
    halfBtn.addEventListener('click', ()=>{ if(state.toAct!==0) return; const potHalf = Math.max(BIG_BLIND, Math.round((state.pot + toCall(0)) * 0.5)); betAmt.value = potHalf; });
    potBtn.addEventListener('click', ()=>{ if(state.toAct!==0) return; const potSize = state.pot + toCall(0); betAmt.value = Math.max(BIG_BLIND, potSize); });
    allinBtn.addEventListener('click', ()=>{ if(state.toAct!==0) return; betAmt.value = allInCap(0); });
    betRaiseBtn.addEventListener('click', ()=>{ if(state.toAct!==0) return; const amt = Number(betAmt.value)||0; playerBetOrRaise(0, amt); });

    // AI Decision (Monte Carlo + heuristics)
    let aiTimer = null;
    function scheduleAI(delay){ if(aiTimer) { try{ clearTimeout(aiTimer); }catch{} aiTimer=null; } aiTimer = setTimeout(()=>{ aiTimer=null; if(state.toAct===1 && !state.players[1].folded && state.street!=='showdown' && !state.animating) aiAct(); }, delay); }
    function maybeAIMove(){ if(state.toAct!==1 || state.players[1].folded || state.street==='showdown') return; scheduleAI(150 + Math.random()*200); }
    function aiAct(){
      const pid=1; const me=state.players[pid]; const hero=state.players[0];
      const need = toCall(pid);
      if(me.stack===0){ 
        state.acted[pid] = true;
        if(bothActedAndEqual() || bothCheckedThisStreet()) endStreet(); 
        else { state.toAct=0; updateControls(); draw(); if(!maybeAutoRunout()){} } 
        return; 
      }
      const iters = state.street==='river'? 800 : state.street==='turn'? 600 : state.street==='flop'? 500 : 400;
      const eq = estimateEquity(me.hole, state.board, hero.hole, iters);
      const potNow = state.pot;
      const minR = openAmountRange(pid)[0];
      const callEV = need>0 ? (eq*(potNow+need) - (1-eq)*need) : 0;
      const posAdv = (state.dealer===pid && (state.street==='flop'||state.street==='turn'||state.street==='river')) ? 0.02 : 0.0;
      const strong = eq > (0.60 - posAdv);
      const medium = eq > (0.48 - posAdv);
      const weak = eq < (0.36 - posAdv);
      const bluffChance = Math.max(0.03, 0.18 - eq*0.12);
      const rnd = Math.random();
      if(need>0){
        if(callEV < -Math.min(2, BIG_BLIND) && weak && rnd>0.25){
          if(rnd<bluffChance && me.stack>minR) {
            const size = Math.min(allInCap(pid), Math.max(minR, Math.round((potNow+need)* (0.8 + Math.random()*0.6))));
            playerBetOrRaise(pid, size); return;
          }
          playerFold(pid); return;
        }
        if(strong && me.stack>minR && rnd<0.65){
          const mult = state.street==='preflop'? 3.2 : state.street==='flop'? 2.4 : 1.8;
          const size = Math.min(allInCap(pid), Math.max(minR, Math.round((need + potNow) * (mult*0.35))));
          playerBetOrRaise(pid, size); return;
        }
        // Call in all other cases
        playerCall(pid); if(isAllInAndEqual()) { updateControls(); draw(); maybeAutoRunout(); } return;
      } else {
        if(strong || (medium && rnd<0.7) || (rnd<bluffChance && me.stack>minR)){
          const base = state.street==='preflop'? 5 : state.street==='flop'? Math.round(potNow*0.66) : Math.round(potNow*0.55);
          const size = Math.min(allInCap(pid), Math.max(minR, base));
          playerBetOrRaise(pid, size); return;
        }
        // Check
        state.acted[pid] = true;
        if(bothActedAndEqual() || bothCheckedThisStreet()) endStreet(); 
        else { state.toAct=0; updateControls(); draw(); if(!maybeAutoRunout()){} }
      }
    }
    function meTurned(){ state.acted[1]=true; }
    function showLog(msg){ const el=document.getElementById('log'); el.textContent=msg; el.style.display='block'; clearTimeout(showLog._t); showLog._t=setTimeout(()=>{ el.style.display='none'; }, 2200); }

    resize();
    resetHand();
  })();
  </script>
</body>
</html>



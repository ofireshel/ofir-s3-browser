<!doctype html>
<html>
<head>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9669595312999180"
     crossorigin="anonymous"></script>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover">
  <title>Heads-Up Poker</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js"></script>
  <style>
    :root {
      --bg1:#0b1220; --bg2:#0f172a; --felt1:#064e3b; --felt2:#052e2a; --felt3:#031a17;
      --line:#10b981; --panel: rgba(14,23,42,0.95); --muted:#93c5fd; --text:#e2e8f0; --accent:#60a5fa; --accent2:#a78bfa;
    }
    html, body { height:100%; margin:0; background:linear-gradient(135deg,var(--bg2),var(--bg1)); color:var(--text); font-family:'Segoe UI', Arial, sans-serif; }
    .wrap { min-height:100%; display:grid; grid-template-rows:auto 1fr auto; }
    header { display:flex; align-items:center; gap:12px; padding:calc(10px + env(safe-area-inset-top)) 16px 12px 16px; background:var(--panel); border-bottom:1px solid #334155; box-shadow:0 2px 8px rgba(0,0,0,.3); }
    header h1 { margin:0; font-size:20px; font-weight:800; background:linear-gradient(45deg,var(--accent),var(--accent2)); -webkit-background-clip:text; background-clip:text; -webkit-text-fill-color:transparent; }
    header .spacer { flex:1; }
    header a { color:var(--muted); text-decoration:none; padding:6px 10px; border:1px solid #475569; border-radius:8px; }
    #stage { position:relative; padding: 10px; }
    #table { width:100%; height: min(78vh, 780px); display:block; border-radius: 14px; background: radial-gradient(120% 120% at 50% 35%, var(--felt1) 0%, var(--felt2) 70%, var(--felt3) 100%); border: 1px solid #065f46; box-shadow: 0 12px 40px rgba(0,0,0,0.35) inset; }
    #glLayer { position:absolute; inset:10px 10px 70px 10px; border-radius:14px; overflow:hidden; pointer-events:none; }
    #glLayer canvas { width:100% !important; height:100% !important; display:block; }
    #hud { position:absolute; left:12px; right:12px; bottom:12px; display:flex; gap:10px; align-items:center; justify-content:center; flex-wrap:wrap; pointer-events:auto; }
    .btn { padding:10px 14px; border-radius:10px; border:2px solid #475569; background:linear-gradient(135deg,#1e293b,#334155); color:var(--text); font-weight:800; cursor:pointer; min-width:84px; }
    .btn:hover { border-color:var(--accent); transform: translateY(-1px); }
    .btn:disabled { opacity:0.4; cursor:not-allowed; }
    .panel { display:flex; align-items:center; gap:8px; padding:8px 10px; border-radius:10px; background:rgba(2,6,23,0.7); border:1px solid #334155; }
    .amt { width:88px; padding:8px 10px; border-radius:10px; border:2px solid #475569; background:#0b1220; color:var(--text); font-weight:700; }
    .chip { padding:4px 10px; border-radius:999px; border:1px solid #334155; background:rgba(15,23,42,.6); color:#cbd5e1; }
    #log { position:absolute; left:50%; transform:translateX(-50%); top:12px; padding:6px 10px; border-radius:10px; background:rgba(2,6,23,0.7); border:1px solid #334155; color:#e2e8f0; font-weight:700; }
    .result { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); padding:18px 22px; border-radius:12px; background:rgba(2,6,23,0.88); border:1px solid #94a3b8; color:#f8fafc; font-weight:900; text-align:center; display:none; z-index:20; box-shadow: 0 20px 80px rgba(0,0,0,0.45); font-size: clamp(18px, 3.2vw, 34px); }
    footer { display:none; }
    .result .res-btn { margin-top:12px; padding:10px 16px; border-radius:10px; border:2px solid #475569; background:linear-gradient(135deg,#1e293b,#334155); color:#e2e8f0; font-weight:800; cursor:pointer; }
    .result .res-btn:hover { border-color:#60a5fa; transform: translateY(-1px); }
      @media (max-width:768px) {
      .amt { width:72px; }
      #table { height: min(68vh, 640px); }
    }
    @media (max-width:430px) {
      #table { height: min(70svh, 640px); }
      #glLayer { inset: 8px 8px 72px 8px; }
      #hud { display:grid; grid-template-columns: 1fr 1fr; gap:8px; justify-content:stretch; }
      #hud .panel { grid-column: 1 / -1; }
      .btn { min-width:68px; padding:9px 12px; }
      .amt { width:64px; }
    }
  </style>
</head>
<body>
  
  <div class="wrap">
    <header>
      <h1>Heads-Up Poker</h1>
      <span id="blinds" class="chip">Blinds: 1/2</span>
      <span class="spacer"></span>
      <a href="games.html">All Games</a>
    </header>
    <div id="stage">
      <canvas id="table"></canvas>
      <div id="glLayer"></div>
      <div id="result" class="result"></div>
      <div id="log" style="display:none"></div>
      <div id="hud">
        <button id="foldBtn" class="btn">Fold</button>
        <button id="checkCallBtn" class="btn">Check</button>
        <div class="panel">
          <button id="halfBtn" class="btn" title="Bet/Raise 1/2 pot">Â½ Pot</button>
          <button id="potBtn" class="btn" title="Bet/Raise pot">Pot</button>
          <button id="allinBtn" class="btn" title="All-in">All-in</button>
          <input id="betAmt" class="amt" type="number" min="0" step="1" value="2"/>
          <button id="betRaiseBtn" class="btn">Bet</button>
        </div>
      </div>
    </div>
    <footer></footer>
  </div>
  <!-- AdSense moved to bottom to avoid pushing content on mobile -->
  <div style="padding:10px 12px;">
    <ins class="adsbygoogle"
         style="display:block"
         data-ad-client="ca-pub-9669595312999180"
         data-ad-slot="4945715008"
         data-ad-format="auto"
         data-full-width-responsive="true"></ins>
  </div>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
  <script>
  (function(){
    'use strict';
    const yrEl = document.getElementById('yr'); if(yrEl) yrEl.textContent = new Date().getFullYear();
    
    // Multiplayer setup
    const urlParams = new URLSearchParams(window.location.search);
    // Only treat as multiplayer when mandatory params exist; otherwise run single-player
    const isMultiplayer = urlParams.get('mode') === 'multiplayer' && !!urlParams.get('gameId') && !!urlParams.get('playerId');
    const gameId = urlParams.get('gameId');
    const myPlayerId = urlParams.get('playerId');
    const myPlayerName = urlParams.get('playerName');
    let gameWs = null;
    let opponentName = urlParams.get('opponentName') || 'Opponent';
    let assignedPlayerId = null; // Will be set by server
    let heartbeatInterval = null; // For keeping Worker alive
    
    // Initialize multiplayer connection
    if (isMultiplayer && gameId && myPlayerId) {
      console.log('Initializing multiplayer mode:', {
        gameId,
        myPlayerId,
        myPlayerName,
        opponentName
      });
      initMultiplayer();
    } else {
      console.log('Starting single-player mode');
      // Start single-player AI watchdog to ensure the bot acts when it's their turn
      try { if (window.__aiWatchdog) clearInterval(window.__aiWatchdog); } catch {}
      window.__aiWatchdog = setInterval(() => {
        try {
          if (!isMultiplayer && state && state.toAct===1 && !state.animating && state.street!=='showdown') {
            scheduleAI(0);
          }
        } catch {}
      }, 400);
    }
    // Canvas setup
    const canvas = document.getElementById('table');
    const ctx = canvas.getContext('2d', { alpha:false, desynchronized:true });
    // WebGL (PixiJS) stage for cards animation
    const glContainer = document.getElementById('glLayer');
    let pixiApp = null;
    const cardTextureCache = new Map(); // key: `${faceUp?1:0}_${r}_${s}_${scale}` or `back_${scale}`
    const spritePool = [];
    function getPooledSprite(texture){
      const s = spritePool.pop();
      if(s){ s.texture = texture; s.visible = true; s.alpha = 1; s.scale.set(1,1); return s; }
      const sp = new PIXI.Sprite(texture); sp.anchor.set(0.5,0.5); return sp;
    }
    function releaseSprite(sprite){ if(!sprite) return; sprite.visible=false; try{ sprite.parent && sprite.parent.removeChild(sprite); }catch{} spritePool.push(sprite); }
    function getCardTexture(card, faceUp, scale){
      if(!pixiApp) return null;
      const sc = Math.round((scale||1)*100)/100;
      if(!faceUp){
        const k = `back_${sc}`; if(cardTextureCache.has(k)) return cardTextureCache.get(k);
        const w=60*sc, h=86*sc, r=9*sc;
        const g = new PIXI.Graphics();
        g.beginFill(0xf8fafc); g.lineStyle(2, 0xcbd5e1, 1); g.drawRoundedRect(-w/2, -h/2, w, h, r); g.endFill();
        const back = new PIXI.Graphics(); back.beginFill(0x1d4ed8); back.drawRoundedRect(-w/2,-h/2,w,h,r); back.endFill();
        const c = new PIXI.Container(); c.addChild(back); const tex = pixiApp.renderer.generateTexture(c, { resolution: 1 }); cardTextureCache.set(k, tex); return tex;
      } else {
        const k = `f_${card.r}_${card.s}_${sc}`; if(cardTextureCache.has(k)) return cardTextureCache.get(k);
        const w=60*sc, h=86*sc, r=9*sc;
        const suitColors=[0x111827,0xef4444,0xef4444,0x065f46];
        const gfx = new PIXI.Graphics();
        gfx.beginFill(0xf8fafc); gfx.lineStyle(2, 0xcbd5e1, 1); gfx.drawRoundedRect(-w/2, -h/2, w, h, r); gfx.endFill();
        const rankText = new PIXI.Text(rankStr(card.r), {fontFamily:'Arial Black', fontSize:14*sc, fill:suitColors[card.s], resolution:1});
        rankText.anchor.set(0,0); rankText.position.set(-w/2+8,-h/2+6);
        const suitText = new PIXI.Text(SUIT_EMO[card.s], {fontFamily:'Segoe UI Emoji', fontSize:14*sc, fill:suitColors[card.s], resolution:1});
        suitText.anchor.set(0,0); suitText.position.set(-w/2+8,-h/2+24);
        const centerSuit = new PIXI.Text(SUIT_EMO[card.s], {fontFamily:'Segoe UI Emoji', fontSize:30*sc, fill:suitColors[card.s], resolution:1});
        centerSuit.anchor.set(0.5,0.5); centerSuit.position.set(0,8);
        const cont = new PIXI.Container(); cont.addChild(gfx, rankText, suitText, centerSuit);
        const tex = pixiApp.renderer.generateTexture(cont, { resolution: 1 }); cardTextureCache.set(k, tex); return tex;
      }
    }
    let glCards = []; // sprites for animated cards
    // Slightly lower DPR cap for smoother animations on mid devices
    let DPR = Math.min(1.25, window.devicePixelRatio || 1);
    // Offscreen background layer to reduce per-frame cost
    let bgCanvas = document.createElement('canvas');
    let bgCtx = bgCanvas.getContext('2d');
    let bgImage = null; let bgImageLoaded = false; let bgImageLoading = false;
    function resize(){
      const r = canvas.getBoundingClientRect();
      DPR = Math.min(1.25, window.devicePixelRatio || 1);
      canvas.width = Math.max(1, Math.floor(r.width * DPR));
      canvas.height = Math.max(1, Math.floor(r.height * DPR));
      bgCanvas.width = canvas.width;
      bgCanvas.height = canvas.height;
      buildBackground();
      // Setup or resize Pixi
      const w = Math.floor(r.width);
      const h = Math.floor(r.height);
      try{
        if(window.PIXI && PIXI.Application){
          const small = isSmallScreen();
          if(!pixiApp){
            pixiApp = new PIXI.Application({
              resizeTo: glContainer,
              antialias: !small,
              resolution: small ? 1 : Math.min(1.5, window.devicePixelRatio || 1),
              backgroundAlpha: 0,
              powerPreference: small ? 'low-power' : 'high-performance'
            });
            glContainer.innerHTML=''; glContainer.appendChild(pixiApp.view);
            pixiApp.renderer.roundPixels = true;
          } else {
            // Update renderer resolution on mobile for smoother performance
            const targetRes = small ? 1 : Math.min(1.5, window.devicePixelRatio || 1);
            if(pixiApp.renderer.resolution !== targetRes){
              pixiApp.renderer.resolution = targetRes;
            }
            pixiApp.renderer.resize(w, h);
          }
        }
      } catch(e){
        // WebGL not available; continue with canvas-only rendering
        pixiApp = null;
        glContainer.innerHTML='';
      }
      draw();
    }
    function isSmallScreen(){
      try{
        const w = Math.min(window.innerWidth||0, document.documentElement.clientWidth||1);
        return w > 0 && w <= 430;
      }catch{ return false; }
    }
    window.addEventListener('resize', resize);
    // Player handle
    function getHandle(){
      try {
        let h = localStorage.getItem('poker_handle');
        if(!h){ h = 'Player-' + Math.floor(Math.random()*1e6).toString(36).toUpperCase(); localStorage.setItem('poker_handle', h); }
        return h;
      } catch { return 'Player-' + Math.floor(Math.random()*1e6).toString(36).toUpperCase(); }
    }
    const HUMAN_NAME = getHandle();
    const AI_NAME = 'OrbitBot';

    // Game state
    const SMALL_BLIND = 1, BIG_BLIND = 2, START_STACK = 200;
    // Background portrait image (royaltyâfree). Replace URL to customize.
    const TABLE_BG_URL = 'https://images.unsplash.com/photo-1494790108377-be9c29b29330?auto=format&fit=crop&w=2400&q=80';
    const TABLE_BG_OPACITY = 0.18; // 0..1, how visible the photo sits behind the felt
    // Secure randomness helpers
    function secureRandomIntInclusive(max){
      max = Math.floor(max);
      if(max <= 0) return 0;
      const range = max + 1;
      if(window.crypto && window.crypto.getRandomValues){
        const maxUint = 0x100000000; // 2^32
        const bucket = Math.floor(maxUint / range);
        const limit = bucket * range - 1;
        const arr = new Uint32Array(1);
        while(true){
          window.crypto.getRandomValues(arr);
          const v = arr[0];
          if(v <= limit){ return v % range; }
        }
      }
      // Fallback (non-crypto)
      return (Math.random() * range) | 0;
    }
    function secureRandomBool(){ return secureRandomIntInclusive(1) === 1; }

    const state = {
      handId: 0,
      dealer: secureRandomBool() ? 0 : 1, // 0 human, 1 ai
      players: [
        { name: isMultiplayer ? (decodeURIComponent(myPlayerName) || 'You') : HUMAN_NAME, stack: START_STACK, hole: [], folded:false, isAI:false },
        { name: isMultiplayer ? (decodeURIComponent(opponentName) || 'Opponent') : AI_NAME, stack: START_STACK, hole: [], folded:false, isAI:!isMultiplayer }
      ],
      deck: [], board: [],
      pot: 0,
      street: 'preflop', // preflop, flop, turn, river, showdown
      toAct: 0,
      lastAggressor: -1,
      curBet: 0,
      betThisRound: [0,0],
      actionOpen: true,
      message: '',
      revealed: { human:0, ai:0, board:0 },
        moving: null, // {from:{x,y}, to:{x,y}, start, dur, card, faceUp}
        animating: false,
        glAnimating: false,
      acted: [false, false],
      overlayShown: false,
      handAdvanced: false
    };

    // Deck
    const SUITS = ['â ','â¥','â¦','â£'];
    function newDeck(){ const d=[]; for(let s=0;s<4;s++){ for(let r=2;r<=14;r++){ d.push({r,s}); } } return d; }
    // FisherâYates with secure randomness (rejection sampling to avoid modulo bias)
    function shuffle(a){
      for(let i=a.length-1;i>0;i--){
        const j = secureRandomIntInclusive(i);
        const tmp = a[i]; a[i] = a[j]; a[j] = tmp;
      }
    }
    function cardStr(c){ const ranks='--23456789TJQKA'; return ranks[c.r] + SUITS[c.s]; }

    // Hand evaluation (7-card)
    function eval7(cards){
      const bySuit = [[],[],[],[]];
      const counts = new Map();
      let maskRanks=0;
      for(const c of cards){ bySuit[c.s].push(c.r); counts.set(c.r,(counts.get(c.r)||0)+1); maskRanks|=1<<(c.r); }
      for(let s=0;s<4;s++) bySuit[s].sort((a,b)=>b-a);
      const ranks = Array.from(counts.keys()).sort((a,b)=> b-a);
      function bestStraightFromMask(mask){
        if(mask & (1<<14)) mask |= 1<<1;
        for(let hi=14; hi>=5; hi--){ let ok=true; for(let k=0;k<5;k++){ if(!(mask & (1<<(hi-k)))){ ok=false; break; } } if(ok) return hi; }
        return 0;
      }
      let flushSuit=-1; for(let s=0;s<4;s++){ if(bySuit[s].length>=5){ flushSuit=s; break; } }
      if(flushSuit>=0){
        const maskFlush = bySuit[flushSuit].reduce((m,r)=>m|(1<<r),0);
        let hiSF = bestStraightFromMask(maskFlush);
        if(hiSF){
          const rank = 8*1e9 + hiSF*1e6;
          return { rank, cat:8, kickers:[hiSF] };
        }
      }
      const groups = {4:[],3:[],2:[],1:[]};
      for(const r of ranks){ groups[counts.get(r)].push(r); }
      if(groups[4].length){
        const four=groups[4][0]; const rest=ranks.filter(x=>x!==four);
        return { rank: 7*1e9 + four*1e6 + (rest[0]||0)*1e3, cat:7, kickers:[four,rest[0]||0] };
      }
      if(groups[3].length){
        if(groups[3].length>=2 || groups[2].length){
          const trips = groups[3][0];
          const pair = groups[3].length>=2 ? groups[3][1] : groups[2][0];
          return { rank: 6*1e9 + trips*1e6 + pair*1e3, cat:6, kickers:[trips,pair] };
        }
      }
      if(flushSuit>=0){
        const top5 = bySuit[flushSuit].slice(0,5);
        return { rank: 5*1e9 + top5[0]*1e6 + top5[1]*1e4 + top5[2]*1e2 + top5[3], cat:5, kickers: top5 };
      }
      const hiSt = bestStraightFromMask(maskRanks);
      if(hiSt){ return { rank: 4*1e9 + hiSt*1e6, cat:4, kickers:[hiSt] }; }
      if(groups[3].length){
        const t=groups[3][0]; const rest=ranks.filter(x=>x!==t); return { rank: 3*1e9 + t*1e6 + (rest[0]||0)*1e4 + (rest[1]||0)*1e2, cat:3, kickers:[t, rest[0]||0, rest[1]||0] };
      }
      if(groups[2].length>=2){
        const [p1,p2]=groups[2].slice(0,2); const rest=ranks.filter(x=>x!==p1&&x!==p2);
        return { rank: 2*1e9 + p1*1e6 + p2*1e4 + (rest[0]||0)*1e2, cat:2, kickers:[p1,p2, rest[0]||0] };
      }
      if(groups[2].length===1){
        const p=groups[2][0]; const rest=ranks.filter(x=>x!==p);
        return { rank: 1*1e9 + p*1e6 + (rest[0]||0)*1e4 + (rest[1]||0)*1e2 + (rest[2]||0), cat:1, kickers:[p, rest[0]||0, rest[1]||0, rest[2]||0] };
      }
      const top5 = ranks.slice(0,5); while(top5.length<5) top5.push(0);
      return { rank: top5[0]*1e6 + top5[1]*1e4 + top5[2]*1e2 + top5[3]*1, cat:0, kickers: top5 };
    }
    function compareHands(a,b){ return a.rank===b.rank ? 0 : (a.rank>b.rank?1:-1); }
    function handLabel(h){
      const names=['High Card','Pair','Two Pair','Three of a Kind','Straight','Flush','Full House','Four of a Kind','Straight Flush'];
      return names[h.cat] || 'Hand';
    }

    // Detailed hand description using eval7 output (cat + kickers)
    function rankWord(r){
      const map={11:'Jack',12:'Queen',13:'King',14:'Ace'}; if(r<=10) return String(r); return map[r]||String(r); }
    function pluralRank(r){ const w=rankWord(r); return (r===6? '6':'') && (w==="6"? '6s': (w.match(/\d/)? w+'s' : (w+ 's'))); }
    function describeHand(ev){
      if(!ev) return 'Hand';
      const cat=ev.cat, k=ev.kickers||[];
      switch(cat){
        case 0: return `High Card ${rankWord(k[0]||0)}`;
        case 1: return `Pair of ${pluralRank(k[0]||0)}`;
        case 2: return `Two Pair (${rankWord(k[0]||0)}s and ${rankWord(k[1]||0)}s)`;
        case 3: return `Three of a Kind (${rankWord(k[0]||0)}s)`;
        case 4: return `Straight to ${rankWord(k[0]||0)}`;
        case 5: return `Flush (${rankWord(k[0]||0)} high)`;
        case 6: return `Full House (${rankWord(k[0]||0)}s over ${rankWord(k[1]||0)}s)`;
        case 7: return `Four of a Kind (${rankWord(k[0]||0)}s)`;
        case 8: return `Straight Flush to ${rankWord(k[0]||0)}`;
        default: return handLabel(ev);
      }
    }

    // Monte Carlo equity estimation vs 1 opponent
    function estimateEquity(hole, board, dead, iters){
      const used = new Set(dead.map(cardStr));
      hole.forEach(c=>used.add(cardStr(c)));
      board.forEach(c=>used.add(cardStr(c)));
      const deck = []; for(let s=0;s<4;s++) for(let r=2;r<=14;r++){ const c={r,s}; if(!used.has(cardStr(c))) deck.push(c);} 
      let wins=0, ties=0;
      const needBoard = 5 - board.length;
      for(let i=0;i<iters;i++){
        const a = (Math.random()*deck.length)|0; const c1=deck[a];
        const b = (Math.random()*(deck.length-1)|0); const c2=deck[b>=a?b+1:b];
        const rem = deck.filter((c,idx)=> idx!==a && idx!==(b>=a?b+1:b));
        const run=[]; for(let k=0;k<needBoard;k++){ const j=(Math.random()*rem.length)|0; run.push(rem.splice(j,1)[0]); }
        const myEval = eval7(hole.concat(board, run));
        const oppEval = eval7([c1,c2].concat(board, run));
        const cmp = compareHands(myEval, oppEval);
        if(cmp>0) wins++; else if(cmp===0) ties++;
      }
      return (wins + ties*0.5) / Math.max(1,iters);
    }

    // Rendering helpers
    function buildBackground(){
      const w=bgCanvas.width, h=bgCanvas.height; const bctx=bgCtx;
      bctx.setTransform(1,0,0,1,0,0); bctx.clearRect(0,0,w,h);
      // Background portrait image layer (soft)
      if(!bgImageLoaded && !bgImageLoading){
        bgImageLoading = true; bgImage = new Image(); bgImage.crossOrigin='anonymous'; bgImage.onload=()=>{ bgImageLoaded=true; buildBackground(); }; bgImage.onerror=()=>{ bgImageLoaded=false; }; bgImage.src = TABLE_BG_URL;
      }
      if(bgImageLoaded){
        const iw=bgImage.naturalWidth, ih=bgImage.naturalHeight;
        // cover
        const scale = Math.max(w/iw, h/ih);
        const dw = iw*scale, dh = ih*scale;
        bctx.save(); bctx.globalAlpha = TABLE_BG_OPACITY; bctx.drawImage(bgImage, (w-dw)/2, (h-dh)/2, dw, dh); bctx.restore();
      }
      // Static felt gradient
      const bgGrad = bctx.createLinearGradient(0,0,0,h);
      bgGrad.addColorStop(0,'#064e3b'); bgGrad.addColorStop(1,'#052e2a');
      bctx.fillStyle=bgGrad; bctx.fillRect(0,0,w,h);
      // Table shape
      bctx.save();
      // Keep desktop placement but slightly increase vertical radius on small screens to fully frame board
      const yOff = 0;
      bctx.translate(w/2, h/2 + yOff);
      const R=Math.min(w,h) * 0.42;
      const r=R * (isSmallScreen()? 0.40 : 0.35);
      bctx.fillStyle='#065f46'; bctx.strokeStyle= getGradient('#10b981','#34d399'); bctx.lineWidth=8*DPR;
      roundTablePath.call({ctx:bctx}, R, r);
      function path(Rr, rr){ bctx.beginPath(); bctx.moveTo(-Rr, -rr); bctx.lineTo(Rr, -rr); bctx.arc(Rr,0,rr,-Math.PI/2,Math.PI/2); bctx.lineTo(-Rr, rr); bctx.arc(-Rr,0,rr,Math.PI/2,-Math.PI/2); bctx.closePath(); }
      bctx.beginPath(); bctx.moveTo(-R, -r); bctx.lineTo(R, -r); bctx.arc(R,0,r,-Math.PI/2,Math.PI/2); bctx.lineTo(-R, r); bctx.arc(-R,0,r,Math.PI/2,-Math.PI/2); bctx.closePath();
      bctx.fill(); bctx.stroke();
      // Static soft vignette
      const g=bctx.createRadialGradient(w/2,h*0.35,Math.min(w,h)*0.05, w/2,h*0.35, Math.max(w,h)*0.7);
      g.addColorStop(0,'rgba(16,185,129,0.12)'); g.addColorStop(1,'rgba(16,185,129,0)');
      bctx.fillStyle=g; bctx.fillRect(0,0,w,h);
      bctx.restore();
    }

    function drawTable(){
      const w=canvas.width, h=canvas.height; ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,w,h);
      ctx.drawImage(bgCanvas, 0, 0);
    }
    function getGradient(a,b){ const g=ctx.createLinearGradient(0,0,0,canvas.height); g.addColorStop(0,a); g.addColorStop(1,b); return g; }
    function roundTablePath(R,r){ ctx.beginPath(); ctx.moveTo(-R, -r); ctx.lineTo(R, -r); ctx.arc(R,0,r,-Math.PI/2,Math.PI/2); ctx.lineTo(-R, r); ctx.arc(-R,0,r,Math.PI/2,-Math.PI/2); ctx.closePath(); }
    function drawChipStack(x,y,amount){ ctx.save(); ctx.translate(x,y); const chips=Math.min(8, Math.max(1, Math.round(amount/5))); for(let i=0;i<chips;i++){ ctx.fillStyle='rgba(236,72,153,'+(0.4+0.05*i)+')'; ctx.beginPath(); ctx.ellipse(0, -i*3*DPR, 16*DPR, 6*DPR, 0,0,Math.PI*2); ctx.fill(); } ctx.fillStyle='#fbbf24'; ctx.font = `${12*DPR}px Segoe UI`; ctx.textAlign='center'; ctx.textBaseline='bottom'; ctx.fillText(amount.toString(), 0, -chips*3*DPR-2*DPR); ctx.restore(); }
    // Detailed chip visuals for total stacks (left of cards)
    const CHIP_DENOMS = [500, 100, 25, 5, 1];
    const CHIP_COLORS = { 1:'#e5e7eb', 5:'#ef4444', 25:'#10b981', 100:'#111827', 500:'#a78bfa' };
    function buildChipColumns(amount){
      const cols=[]; let remain = Math.max(0, Math.floor(amount));
      for(const v of CHIP_DENOMS){
        let cnt = Math.floor(remain / v); remain -= cnt * v;
        while(cnt>0){ const take = Math.min(10, cnt); cols.push({ value:v, color:CHIP_COLORS[v]||'#cbd5e1', count:take }); cnt -= take; }
      }
      if(remain>0) cols.push({ value:1, color:CHIP_COLORS[1], count:remain });
      return cols;
    }
    function drawChipDisc(px, py, color){
      ctx.save();
      // base with subtle 3D shading
      const grad = ctx.createRadialGradient(px - 6*DPR, py - 4*DPR, 2*DPR, px, py, 16*DPR);
      grad.addColorStop(0, '#ffffff18');
      grad.addColorStop(1, '#00000025');
      ctx.beginPath(); ctx.ellipse(px, py, 16*DPR, 6.5*DPR, 0, 0, Math.PI*2);
      ctx.fillStyle = color; ctx.fill();
      ctx.strokeStyle='#0b0f18'; ctx.lineWidth=1.2*DPR; ctx.stroke();
      // inner ring
      ctx.beginPath(); ctx.ellipse(px, py, 12*DPR, 4.8*DPR, 0, 0, Math.PI*2);
      ctx.strokeStyle='rgba(255,255,255,0.45)'; ctx.lineWidth=1*DPR; ctx.stroke();
      // edge notches
      ctx.save(); ctx.globalAlpha=0.6; ctx.strokeStyle='rgba(255,255,255,0.6)'; ctx.lineWidth=1*DPR;
      for(let k=0;k<8;k++){
        const ang = (Math.PI*2/8)*k; const ex = px + Math.cos(ang)*14*DPR; const ey = py + Math.sin(ang)*5.2*DPR;
        ctx.beginPath(); ctx.moveTo(ex, ey); ctx.lineTo(ex*0.995 + px*0.005, ey*0.995 + py*0.005); ctx.stroke();
      }
      ctx.restore();
      // glossy highlight
      ctx.beginPath(); ctx.ellipse(px - 5*DPR, py - 3.5*DPR, 6*DPR, 2.2*DPR, -0.3, 0, Math.PI*2); ctx.fillStyle='rgba(255,255,255,0.18)'; ctx.fill();
      // ambient shadow
      ctx.beginPath(); ctx.ellipse(px + 2*DPR, py + 3.3*DPR, 14*DPR, 2*DPR, 0, 0, Math.PI*2); ctx.fillStyle='rgba(0,0,0,0.18)'; ctx.fill();
      ctx.restore();
    }
    function drawChipColumn(px, py, color, count){
      const gap = 3.2*DPR; for(let i=0;i<count;i++){ drawChipDisc(px, py - i*gap, color); }
    }
function drawChipBank(anchorX, anchorY, amount, labelY){
      const cols = buildChipColumns(amount);
      const step = (isSmallScreen()? 18:24)*DPR; // horizontal spacing
      const totalWidth = Math.max(1, cols.length) * step;
      let x = anchorX; // start near cards and move leftwards
      const bankYOffset = (isSmallScreen()? 16:18) * DPR;
      for(let i=0;i<cols.length;i++){
        const c = cols[i]; drawChipColumn(x, anchorY + bankYOffset, c.color, c.count); x -= step;
      }
      // label centered above the chip bank
      const centerX = anchorX - ((cols.length-1)*step)/2;
      const labelPosY = (typeof labelY === 'number') ? labelY : (anchorY - (isSmallScreen()? 30:14)*DPR);
      ctx.save(); ctx.fillStyle='#e2e8f0'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font = `${(isSmallScreen()?20:18)*DPR}px Arial Black`; ctx.fillText(String(amount), centerX, labelPosY); ctx.restore();
    }

    // Large bet indicator to the right of hole cards
function drawBetIndicator(anchorX, anchorY, amount, labelY){
      if(!amount || amount<=0) return;
      let x = anchorX + (isSmallScreen()? 84:190)*DPR;
      const bankYOffset = (isSmallScreen()? 16:18) * DPR;
      const y = anchorY + bankYOffset;
      // clamp to screen
      const maxX = canvas.width - 16*DPR;
      if(x > maxX) x = maxX;
      // draw a short, prominent stack
      const sample = Math.min(6, Math.max(3, Math.round(Math.log10(amount+1))+2));
      const palette = [CHIP_COLORS[25], CHIP_COLORS[100], CHIP_COLORS[5], CHIP_COLORS[500]].filter(Boolean);
      for(let i=0;i<sample;i++){
        const col = palette[i % palette.length] || '#cbd5e1';
        drawChipDisc(x + (i%2)*4*DPR, y - i*4*DPR, col);
      }
      // big amount text centered above the mini stack
      const textY = (typeof labelY === 'number') ? labelY : (y - (isSmallScreen()? 28:16)*DPR);
      // Center label over the mini stack (nudge slightly left)
      const stackCenterX = x + 2*DPR;
      const textX = Math.min(stackCenterX, canvas.width - 16*DPR);
      ctx.save(); ctx.fillStyle='#f8fafc'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font = `${(isSmallScreen()?22:22)*DPR}px Arial Black`;
      ctx.fillText(String(amount), textX, textY);
      ctx.restore();
    }
    function drawDealerButton(x,y){
      ctx.save();
      ctx.translate(x,y);
      const R = 14*DPR;
      // Outer shadow
      ctx.shadowColor = 'rgba(0,0,0,0.35)';
      ctx.shadowBlur = 6*DPR;
      // Gradient fill
      const grad = ctx.createRadialGradient(-R*0.4, -R*0.4, R*0.4, 0, 0, R);
      grad.addColorStop(0, '#f3f4f6');
      grad.addColorStop(1, '#d1d5db');
      ctx.beginPath(); ctx.arc(0,0, R, 0, Math.PI*2);
      ctx.fillStyle = grad; ctx.fill();
      // Outer ring
      ctx.shadowBlur = 0;
      ctx.strokeStyle='#111827'; ctx.lineWidth=2.2*DPR; ctx.stroke();
      // Inner ring
      ctx.beginPath(); ctx.arc(0,0, R-4*DPR, 0, Math.PI*2);
      ctx.strokeStyle='#6b7280'; ctx.lineWidth=1.4*DPR; ctx.stroke();
      // Letter D
      ctx.fillStyle='#111827';
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.font = `${12*DPR}px Arial Black`;
      ctx.fillText('D', 0, 0);
      ctx.restore();
    }
    // Suit colors: hearts/diamonds red, spades black, clubs dark green
    function suitColor(s){
      if(s===1 || s===2) return '#ef4444'; // hearts, diamonds
      if(s===3) return '#065f46'; // clubs
      return '#111827'; // spades
    }
    function rankStr(r){
      if(r===10) return '10';
      return '--23456789TJQKA'[r];
    }
    const SUIT_EMO = ['â ','â¥','â¦','â£'];
    function drawCard(x,y,card,faceUp=true){
      const sc = isSmallScreen()? 0.9 : 1;
      const w=81*DPR*sc, h=116*DPR*sc, r=12*DPR*sc; ctx.save(); ctx.translate(x,y); ctx.shadowColor='rgba(0,0,0,0.4)'; ctx.shadowBlur=(isSmallScreen()? 7:11)*DPR*sc; roundedRect(-w/2,-h/2,w,h,r);
      if(faceUp){
        // classic card face
        ctx.fillStyle='#ffffff'; ctx.strokeStyle='#b6c2cf'; ctx.lineWidth=2.2*DPR*sc; ctx.fill(); ctx.stroke();
        // subtle inner border
        roundedRect(-w/2+4*DPR*sc,-h/2+4*DPR*sc,w-8*DPR*sc,h-8*DPR*sc,r*0.8); ctx.strokeStyle='#e2e8f0'; ctx.lineWidth=1.2*DPR*sc; ctx.stroke();
        // corners and center pip
        ctx.fillStyle=suitColor(card.s); ctx.textAlign='left'; ctx.textBaseline='top';
        ctx.font = `${22*DPR*sc}px Arial Black`; ctx.fillText(rankStr(card.r), -w/2+9*DPR*sc, -h/2+7*DPR*sc);
        ctx.font = `${22*DPR*sc}px Segoe UI Emoji`; ctx.fillText(SUIT_EMO[card.s], -w/2+9*DPR*sc, -h/2+32*DPR*sc);
        ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font = `${49*DPR*sc}px Segoe UI Emoji`; ctx.fillText(SUIT_EMO[card.s], 0, 10*DPR*sc);
      } else {
        // classic blue back with bordered lattice pattern
        ctx.fillStyle='#114b8b'; ctx.strokeStyle='#0b3561'; ctx.lineWidth=2.4*DPR*sc; ctx.fill(); ctx.stroke();
        // bordered lattice
        ctx.save();
        roundedRect(-w/2+8*DPR*sc,-h/2+8*DPR*sc,w-16*DPR*sc,h-16*DPR*sc,r*0.5); ctx.strokeStyle='#e5e7eb'; ctx.lineWidth=1.6*DPR*sc; ctx.stroke();
        ctx.beginPath(); roundedRect(-w/2+10*DPR*sc,-h/2+10*DPR*sc,w-20*DPR*sc,h-20*DPR*sc,r*0.4); ctx.clip();
        ctx.globalAlpha=0.35; ctx.strokeStyle='#cfe3ff'; ctx.lineWidth=1*DPR*sc;
        for(let y=-h/2; y<h/2; y+=9*DPR*sc){ ctx.beginPath(); ctx.moveTo(-w/2,y); ctx.lineTo(w/2,y+ w); ctx.stroke(); }
        for(let y=-h/2; y<h/2; y+=9*DPR*sc){ ctx.beginPath(); ctx.moveTo(w/2,y); ctx.lineTo(-w/2,y+ w); ctx.stroke(); }
        ctx.restore(); ctx.globalAlpha=1;
      }
      ctx.restore();
    }
    // WebGL fly card using PixiJS for ultra smooth animation
    function flyCard(from, to, card, faceUp, durMs, onDone){
      try{
        const sc = isSmallScreen()? 0.9 : 1;
        const texture = getCardTexture(card, !!faceUp, sc) || null;
        const sprite = texture ? getPooledSprite(texture) : new PIXI.Container();
        // map logical coords to pixi coords
        const rect = canvas.getBoundingClientRect();
        const px = (valX,valY)=> [valX / DPR, valY / DPR]; // canvas coords -> CSS pixels
        const [sx,sy] = px(from.x, from.y);
        sprite.position.set(sx, sy);
        pixiApp.stage.addChild(sprite);
        const start=performance.now(), D=Math.max(100, durMs);
        function tick(){
          const t=Math.min(1, (performance.now()-start)/D);
          const ease = t<0.5 ? 2*t*t : -1+(4-2*t)*t; // smoother easeInOut
          const [nx,ny] = px(from.x + (to.x-from.x)*ease, from.y + (to.y-from.y)*ease);
          sprite.position.set(nx, ny);
          if(t<1){ requestAnimationFrame(tick); }
          else { releaseSprite(sprite); if(onDone) onDone(); }
        }
        requestAnimationFrame(tick);
      }catch(e){
        // Fallback to canvas-based moving if WebGL fails
        state.moving = { from, to, start: performance.now(), dur: Math.max(100, durMs), card, faceUp, onDone };
        requestAnimationFrame(draw);
      }
    }
    function roundedRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
function positions(){
      const w=canvas.width, h=canvas.height; const cx=w/2, cy=h/2; const boardY = cy + (isSmallScreen()? 10:-14)*DPR; const gap = (isSmallScreen()? 74 : 96)*DPR;
      return {
        board: [
          [cx-2*gap, boardY],
          [cx-gap,   boardY],
          [cx,       boardY],
          [cx+gap,   boardY],
          [cx+2*gap, boardY]
        ],
        pot: [cx, cy - (isSmallScreen()? 10:56)*DPR],
        human: { name:[cx, h-(isSmallScreen()? 16:28)*DPR], cards:[cx-45*DPR, h-(isSmallScreen()? 120:130)*DPR, cx+45*DPR, h-(isSmallScreen()? 120:130)*DPR], chips:[cx+150*DPR, h-(isSmallScreen()? 122:135)*DPR] },
        ai:    { name:[cx, (isSmallScreen()? 14:22)*DPR],   cards:[cx-45*DPR, (isSmallScreen()? 118:130)*DPR,    cx+45*DPR, (isSmallScreen()? 118:130)*DPR],    chips:[cx+180*DPR, (isSmallScreen()? 46:60)*DPR] }
      };
    }
    function draw(){
      drawTable();
      const p=positions();
      ctx.fillStyle='#e2e8f0'; ctx.textAlign='center'; ctx.textBaseline='middle';
      const nameSizePx = (isSmallScreen()?16:14) * 1.5 * DPR; // 50% larger font
      ctx.save();
      ctx.shadowColor = 'rgba(0,0,0,0.55)';
      ctx.shadowBlur = 6*DPR;
      ctx.shadowOffsetY = 2*DPR;
      ctx.font = `${nameSizePx}px Segoe UI`;
      // In multiplayer, show player names from their own perspective
      if (isMultiplayer) {
        const myId = getMyId();
        const opponentId = 1 - myId;
        const myName = decodeURIComponent(myPlayerName) || 'You';
        const oppName = decodeURIComponent(opponentName) || 'Opponent';
        
        // Always show "my name" in human position (bottom) and opponent in AI position (top)
        ctx.fillText(myName, p.human.name[0], p.human.name[1]);
        ctx.fillText(oppName, p.ai.name[0], p.ai.name[1]);
      } else {
        // Single player mode
        ctx.fillText(`${state.players[0].name}`, p.human.name[0], p.human.name[1]);
        ctx.fillText(`${state.players[1].name}`, p.ai.name[0], p.ai.name[1]);
      }
      ctx.restore();
      // Big chip stacks below names
      // Total chip stacks (left of each player's cards); tighter on small screens and align labels with bet amounts
      const alignYHuman = isSmallScreen()? (p.human.cards[1] - 36*DPR) : undefined;
      const alignYAI = isSmallScreen()? (p.ai.cards[1] - 36*DPR) : undefined;
      if (isMultiplayer) {
        const myId = getMyId();
        const opponentId = 1 - myId;
        // Show my stack in human position, opponent stack in AI position
        drawChipBank(p.human.cards[0] - (isSmallScreen()? 64:110)*DPR, p.human.cards[1], state.players[myId].stack, alignYHuman);
        drawChipBank(p.ai.cards[0] - (isSmallScreen()? 70:120)*DPR, p.ai.cards[1], state.players[opponentId].stack, alignYAI);
      } else {
        // Single player mode: original logic
        drawChipBank(p.human.cards[0] - (isSmallScreen()? 64:110)*DPR, p.human.cards[1], state.players[0].stack, alignYHuman);
        drawChipBank(p.ai.cards[0] - (isSmallScreen()? 70:120)*DPR, p.ai.cards[1], state.players[1].stack, alignYAI);
      }
      // Dealer button next to the actual dealer's name from server state; align with perspective
      if (isMultiplayer) {
        const myId = getMyId();
        const isDealerMe = state.dealer === myId;
        const dn = isDealerMe ? p.human.name : p.ai.name;
        const dpos = [dn[0]-(isSmallScreen()? 78:62)*DPR, dn[1]];
        drawDealerButton(dpos[0], dpos[1]);
      } else {
        const dn = state.dealer===0 ? p.human.name : p.ai.name;
        const dpos = [dn[0]-(isSmallScreen()? 78:62)*DPR, dn[1]];
        drawDealerButton(dpos[0], dpos[1]);
      }
      ctx.fillStyle='#fbbf24'; ctx.font = `${18*DPR}px Arial Black`; ctx.fillText(`Pot: ${state.pot}`, p.pot[0], p.pot[1]);
      for(let i=0;i<5;i++){
        const [x,y]=p.board[i]; const c=state.board[i];
        const show = !!c && (i < state.revealed.board);
        drawCard(x,y, c||{r:14,s:0}, show);
      }
      if (isMultiplayer) {
        const myId = getMyId();
        const opponentId = 1 - myId;
        // Show my bet in human position, opponent bet in AI position
        drawBetIndicator(p.human.cards[2], p.human.cards[3], state.betThisRound[myId]||0, alignYHuman);
        drawBetIndicator(p.ai.cards[2], p.ai.cards[3], state.betThisRound[opponentId]||0, alignYAI);
      } else {
        // Single player mode: original logic
        drawBetIndicator(p.human.cards[2], p.human.cards[3], state.betThisRound[0]||0, alignYHuman);
        drawBetIndicator(p.ai.cards[2], p.ai.cards[3], state.betThisRound[1]||0, alignYAI);
      }
      const h0 = state.players[0].hole, h1 = state.players[1].hole;
      if (isMultiplayer) {
        // In multiplayer: always show my cards in human position (bottom), opponent in AI position (top)
        const myId = getMyId();
        const opponentId = 1 - myId;
        
        // My cards (always in human position, always face up)
        if(state.players[myId].hole[0]) {
          drawCard(p.human.cards[0], p.human.cards[1], state.players[myId].hole[0], true);
        }
        if(state.players[myId].hole[1]) {
          drawCard(p.human.cards[2], p.human.cards[3], state.players[myId].hole[1], true);
        }
        
        // Opponent cards (always in AI position, face down unless showdown)
        const showOpponentCards = state.street === 'showdown';
        if(state.players[opponentId].hole[0]) {
          drawCard(p.ai.cards[0], p.ai.cards[1], state.players[opponentId].hole[0], showOpponentCards);
        } else {
          drawCard(p.ai.cards[0], p.ai.cards[1], {r:14,s:0}, false);
        }
        if(state.players[opponentId].hole[1]) {
          drawCard(p.ai.cards[2], p.ai.cards[3], state.players[opponentId].hole[1], showOpponentCards);
        } else {
          drawCard(p.ai.cards[2], p.ai.cards[3], {r:14,s:0}, false);
        }
      } else {
        // Single player mode: original logic
        if(state.revealed.human>=1 && h0[0]) drawCard(p.human.cards[0], p.human.cards[1], h0[0], true);
        if(state.revealed.human>=2 && h0[1]) drawCard(p.human.cards[2], p.human.cards[3], h0[1], true);
        if(state.revealed.ai>=1 && h1[0])    drawCard(p.ai.cards[0],    p.ai.cards[1],    h1[0], state.street==='showdown');
        if(state.revealed.ai>=2 && h1[1])    drawCard(p.ai.cards[2],    p.ai.cards[3],    h1[1], state.street==='showdown');
      }
      // moving card on top
      if(state.moving){
        const m=state.moving; const now=performance.now();
        const t=Math.min(1,(now-m.start)/m.dur);
        // Use smoothstep easing for stable, non-choppy animation on all devices
        const ease = t * t * (3 - 2 * t);
        const x=m.from.x + (m.to.x-m.from.x)*ease; const y=m.from.y + (m.to.y-m.from.y)*ease;
        drawCard(x,y, m.card, m.faceUp);
        if(t>=1){ state.moving=null; if(m.onDone) m.onDone(); }
      }
      if((state.animating && !state.glAnimating) || state.moving) requestAnimationFrame(draw);
    }

    // Betting logic
    function resetHand(){
      state.handId++; state.board=[]; state.pot=0; state.street='preflop'; state.curBet=0; state.betThisRound=[0,0]; state.players.forEach(p=>{p.hole=[]; p.folded=false;}); state.lastAggressor=-1; state.message='';
      state.dealer = 1 - state.dealer;
      state.deck = newDeck(); shuffle(state.deck);
      postBlind(state.dealer, SMALL_BLIND);
      postBlind(1-state.dealer, BIG_BLIND);
      for(let i=0;i<2;i++){
        state.players[state.dealer].hole.push(state.deck.pop());
        state.players[1-state.dealer].hole.push(state.deck.pop());
      }
      state.revealed = { human:0, ai:0, board:0 };
      // Preflop: small blind (dealer) acts first; treat only big blind as already acted
      state.acted = [false, false];
      state.acted[1 - state.dealer] = true;
      state.toAct = state.dealer;
      state.overlayShown = false;
      state.handAdvanced = false;
      state.animating = true;
      updateControls();
      state.animating=true; draw();
      // Ensure canvas has dimensions before animation
      if(canvas.width<10 || canvas.height<10){ setTimeout(startDealAnimation, 50); } else { startDealAnimation(); }
    }
    function postBlind(pid, amt){ const p=state.players[pid]; const pay=Math.min(amt, p.stack); p.stack-=pay; state.betThisRound[pid]+=pay; state.pot+=pay; state.curBet=Math.max(state.curBet, state.betThisRound[pid]); }
    function minRaise(){ const highest=Math.max(state.betThisRound[0], state.betThisRound[1]); const other=Math.min(state.betThisRound[0], state.betThisRound[1]); const lastRaise=Math.max(BIG_BLIND, highest-other); return highest + lastRaise; }
    function canCheck(pid){ return state.betThisRound[pid]===state.curBet; }
    function toCall(pid){ return Math.max(0, state.curBet - state.betThisRound[pid]); }
    function allInCap(pid){ return state.players[pid].stack + state.betThisRound[pid]; }
    function openAmountRange(pid){
      // Open amount: if no bet yet (besides blinds), minimum is BIG_BLIND; otherwise minRaise
      const min = state.curBet===0 ? Math.max(BIG_BLIND, toCall(pid) + BIG_BLIND) : minRaise();
      // Cap by effective stacks (cannot bet more than opponent can ever call)
      const effectiveMax = Math.min(allInCap(pid), allInCap(1-pid));
      const max = Math.max(0, effectiveMax);
      return [Math.min(min,max), max];
    }
    function nextPlayerAfter(pid){ return 1-pid; }
    function bothActedAndEqual(){
      // End the street when there is a bet (curBet>0), both have acted this street,
      // and their committed amounts are equal (i.e., a bet was called). If all-in+equal, auto-runout will handle.
      const allInEqual = isAllInAndEqual();
      const curBetExists = state.curBet > 0;
      const betsEqual = state.betThisRound[0] === state.betThisRound[1];
      const bothActed = state.acted[0] && state.acted[1];
      
      console.log(`bothActedAndEqual check:`, {
        allInEqual: allInEqual,
        curBetExists: curBetExists,
        betsEqual: betsEqual,
        bothActed: bothActed,
        betThisRound: [...state.betThisRound],
        acted: [...state.acted],
        curBet: state.curBet
      });
      
      if(allInEqual) {
        console.log('All-in and equal, returning false');
        return false;
      }
      
      const result = curBetExists && betsEqual && bothActed;
      console.log(`bothActedAndEqual returning: ${result}`);
      return result;
    }
    function bothCheckedThisStreet(){ return state.curBet===0 && state.acted[0] && state.acted[1]; }
    function endStreet(){
      const oldStreet = state.street;
      console.log(`endStreet called! Current street: ${oldStreet}`);
      
      state.street = state.street==='preflop'? 'flop' : state.street==='flop'? 'turn' : state.street==='turn'? 'river' : 'showdown';
      console.log(`Street changed from ${oldStreet} to ${state.street}`);
      
      state.curBet=0; state.betThisRound=[0,0]; state.lastAggressor=-1; state.acted=[false,false];
      // In heads-up postflop, the non-dealer acts first; mirror server
      state.toAct = state.dealer===1? 0 : 1;
      
      if(state.street==='flop'){ 
        console.log('Dealing flop - adding 3 cards to board');
        state.board.push(state.deck.pop(), state.deck.pop(), state.deck.pop()); 
      }
      else if(state.street==='turn' || state.street==='river'){ 
        console.log(`Dealing ${state.street} - adding 1 card to board`);
        state.board.push(state.deck.pop()); 
      }
      
      if(state.street==='showdown') { 
        console.log('Showdown reached');
        doShowdown(); return; 
      }
      
      if(state.street==='flop'){ state.revealed.board = Math.max(state.revealed.board, 3); }
      if(state.street==='turn'){ state.revealed.board = Math.max(state.revealed.board, 4); }
      if(state.street==='river'){ state.revealed.board = Math.max(state.revealed.board, 5); }

      // Ensure we're not blocked by animation
      state.animating = false;
      // If it became my turn (AI) immediately after street change in single-player, act
      if(!isMultiplayer && state.toAct===1){
        scheduleAI(0);
      }
      
      console.log(`endStreet complete. Board now has ${state.board.length} cards, toAct=${state.toAct}`);
      // Multiplayer: server authoritative, no client sync
      if(isMultiplayer){ /* no-op */ }
      updateControls(); draw(); if(!maybeAutoRunout()) {
        if(!isMultiplayer && state.toAct===1 && !state.animating){
          try { aiAct(); } catch { scheduleAI(0); }
        } else {
          maybeAIMove();
        }
      }
      // Safety: if still on this street without action after short delay, force AI act
      if(!isMultiplayer && state.toAct===1){ setTimeout(()=>{ try{ if(state.toAct===1 && state.street!== 'showdown' && !state.animating) aiAct(); }catch{ scheduleAI(100);} }, 200); }
      if(isMultiplayer && assignedPlayerId===0){ try{ sendAction('sync_state'); }catch{} }
    }

    function isAllInAndEqual(){
      return (state.players[0].stack===0 || state.players[1].stack===0) && state.betThisRound[0]===state.betThisRound[1];
    }

    // Auto-deal remaining community cards when players are all-in and bets are matched
    function maybeAutoRunout(){
      if(state.street==='showdown') return false;
      if(!isAllInAndEqual()) return false;

      // Figure out how many board cards remain to reach the river
      const startIdx = Math.max(0, Math.min(5, state.board.length));
      const remaining = 5 - startIdx;
      if(remaining<=0){
        // Already have full board, go to showdown
        doShowdown();
        return true;
      }

      const p=positions();
      const deckPos = { x: canvas.width/2 + 220*DPR, y: canvas.height/2 - 40*DPR };
      state.animating = true; state.glAnimating = !!pixiApp; updateControls();
      const queue = [];
      for(let i=0;i<remaining;i++){
        const idx = startIdx + i;
        if(state.board.length<=idx){ state.board.push(state.deck.pop()); }
        queue.push({ idx, card: state.board[idx], to: { x: p.board[idx][0], y: p.board[idx][1] } });
      }
      function animateNext(){
        if(queue.length===0){
          state.animating=false; state.glAnimating=false; updateControls();
          // Multiplayer: server authoritative, no client sync
          if(isMultiplayer){ /* no-op */ }
          doShowdown(); return;
        }
        const item = queue.shift();
        if(pixiApp){
          getCardTexture(item.card, true, isSmallScreen()?0.9:1);
          flyCard(deckPos, item.to, item.card, true, 110, ()=>{
            state.revealed.board = Math.max(state.revealed.board, item.idx+1);
            animateNext();
          });
        } else {
          state.moving = { from: deckPos, to: item.to, start: performance.now(), dur: 120, card: item.card, faceUp: true, onDone: ()=>{
            state.revealed.board = Math.max(state.revealed.board, item.idx+1);
            animateNext();
          }};
          requestAnimationFrame(draw);
        }
      }
      animateNext();
      return true;
    }

    // Dealing animation (hole cards only; preflop betting before flop)
    function startDealAnimation(){
      const p=positions();
      const deckPos = { x: canvas.width/2 + 220*DPR, y: canvas.height/2 - 40*DPR };
      const seq = [
        { who:'human', idx:0, to:{x:p.human.cards[0], y:p.human.cards[1]}, faceUp:true },
        { who:'ai',    idx:0, to:{x:p.ai.cards[0],    y:p.ai.cards[1]},    faceUp:false },
        { who:'human', idx:1, to:{x:p.human.cards[2], y:p.human.cards[3]}, faceUp:true },
        { who:'ai',    idx:1, to:{x:p.ai.cards[2],    y:p.ai.cards[3]},    faceUp:false }
      ];
      let i=0;
      let progressed=false;
      function step(){
        if(i>=seq.length){
          // Finish dealing hole cards; remain in preflop for betting
          state.animating=false; state.glAnimating=false;
          updateControls();
          draw();
          if(!maybeAutoRunout()) maybeAIMove();
          return;
        }
        const s=seq[i++];
        // Ensure target card exists in state (for board we push on reveal)
        if(s.who==='board' && state.board.length<=s.idx){ state.board.push(state.deck.pop()); }
        const card = s.who==='human' ? state.players[0].hole[s.idx] : s.who==='ai' ? state.players[1].hole[s.idx] : state.board[s.idx];
        // WebGL sprite for the card fly animation (fallbacks to canvas if WebGL missing)
        if(pixiApp){
          state.glAnimating = true;
          getCardTexture(card, !!s.faceUp, isSmallScreen()?0.9:1);
          flyCard(deckPos, s.to, card, s.faceUp, 120, ()=>{
            if(s.who==='human'){ state.revealed.human = Math.max(state.revealed.human, s.idx+1); }
            else if(s.who==='ai'){ state.revealed.ai = Math.max(state.revealed.ai, s.idx+1); }
            else { state.revealed.board = Math.max(state.revealed.board, s.idx+1); }
            progressed=true; setTimeout(()=>{ state.glAnimating=false; draw(); setTimeout(step, 10); }, 0);
          });
        } else {
          state.moving = { from: deckPos, to: s.to, start: performance.now(), dur: 160, card, faceUp: s.faceUp, onDone: ()=>{
            if(s.who==='human'){ state.revealed.human = Math.max(state.revealed.human, s.idx+1); }
            else if(s.who==='ai'){ state.revealed.ai = Math.max(state.revealed.ai, s.idx+1); }
            else { state.revealed.board = Math.max(state.revealed.board, s.idx+1); }
            progressed=true; draw(); setTimeout(step, 10);
          }};
          requestAnimationFrame(draw);
        }
      }
      step();
      // Watchdog: force reveal if animation fails
      setTimeout(()=>{
        if(!progressed){
          state.revealed.human=2; state.revealed.ai=2; // show both hole card backs
          state.animating=false; draw(); updateControls(); if(!maybeAutoRunout()) maybeAIMove();
        }
      }, 1200);
    }
    function doShowdown(){
      if (state.overlayShown) { updateControls(); draw(); return; }
      // Ensure we are in showdown state; reveal only cards actually dealt
      state.street = 'showdown';
      // Keep already-dealt community cards visible; do not force additional reveals on folds
      // state.revealed.board is managed by server push flow; leave it untouched here
      state.revealed.ai = 2;
      const alive = [0,1].filter(i=>!state.players[i].folded);
      const scores = alive.map(i=>({ i, hand: eval7(state.players[i].hole.concat(state.board)) }));
      let best = scores[0]; for(const s of scores){ if(compareHands(s.hand, best.hand)>0) best=s; }
      const winners = scores.filter(s=>compareHands(s.hand, best.hand)===0).map(s=>s.i);
      const prizeEach = Math.floor(state.pot / winners.length);
      winners.forEach(i=> state.players[i].stack += prizeEach);
      const loser = alive.find(i=> !winners.includes(i));
      const winnerName = winners.length===2 ? 'Both players' : state.players[winners[0]].name;
      const bestEval = eval7(state.players[winners[0]].hole.concat(state.board));
      const oppEval = loser!=null ? eval7(state.players[loser].hole.concat(state.board)) : null;
      const bestLabel = describeHand(bestEval);
      const oppLabel = loser!=null ? describeHand(oppEval) : '';
      const resultEl = document.getElementById('result');
      const contId = 'res-continue';
      resultEl.style.display='block';
      try { resultEl.style.zIndex = '9999'; } catch{}
      if (!state.overlayShown) {
        state.overlayShown = true;
      }
      let msgHtml = (winners.length===2
        ? `Split Pot â ${bestLabel}`
        : `${winnerName} wins ${state.pot} with ${bestLabel}` + (loser!=null? `<br/><span style='font-weight:700;color:#93c5fd'>Beats ${state.players[loser].name}'s ${oppLabel}</span>` : ''));
      if (state.gameOver) {
        msgHtml += `<br/><span style=\"color:#ef4444;font-weight:900;\">Game over! ${state.gameOverWinner} won the game!</span>`;
      }
      resultEl.innerHTML = msgHtml + `<div style=\"margin-top:10px;display:flex;gap:10px;justify-content:center\">${state.gameOver? `<button id=\"res-replay\" class=\"res-btn\">Play again?</button>`:`<button id=\"${contId}\" class=\"res-btn\">Continue</button>`}</div>`;
      state.message = winners.length===2 ? 'Split Pot' : `${state.players[best.i].name} wins ${state.pot}`;
      state.pot=0;
      // Mark showdown start for watchdog
      try { state.showdownStartedAt = performance.now(); } catch{}
      // Multiplayer: server-authoritative, no client sync
      if(isMultiplayer){ /* no-op */ }
      updateControls(); draw();
      try { startShowdownWatchdog(); } catch{}
      let advanced=false; const proceed=()=>{
        if(advanced) return; advanced=true; resultEl.style.display='none';
        if(state.players[0].stack<=0 || state.players[1].stack<=0){
          showLog('Game Over');
          if(isMultiplayer){ try{ sendAction('sync_state'); }catch{} }
          return;
        }
        // Multiplayer: server advances hand; client waits for push
        if(!isMultiplayer){
          resetHand();
        }
        try { stopShowdownWatchdog(); } catch{}
      };
      const btn=document.getElementById(contId); if(btn) btn.onclick=proceed;
      const replay=document.getElementById('res-replay');
      if(replay){ replay.onclick=()=>{ if(isMultiplayer){ try{ sendAction('play_again'); }catch{} } resultEl.style.display='none'; } }
      setTimeout(()=>{ if(!state.gameOver && btn) proceed(); }, 5000);
      // Safety: ensure progression even if overlay click is missed
      if(isMultiplayer){ /* server advances next hand */ }
    }

    // Display-only showdown overlay for the non-acting client when receiving a synced showdown state.
    function showPassiveShowdownOverlay(){
      if (state.overlayShown) return;
      try{
        const alive = [0,1].filter(i=>!state.players[i].folded);
        const scores = alive.map(i=>({ i, hand: eval7(state.players[i].hole.concat(state.board)) }));
        let best = scores[0]; for(const s of scores){ if(compareHands(s.hand, best.hand)>0) best=s; }
        const winners = scores.filter(s=>compareHands(s.hand, best.hand)===0).map(s=>s.i);
        const winnerName = winners.length===2 ? 'Both players' : state.players[winners[0]].name;
        const bestEval = eval7(state.players[winners[0]].hole.concat(state.board));
        const loser = alive.find(i=> !winners.includes(i));
        const oppEval = loser!=null ? eval7(state.players[loser].hole.concat(state.board)) : null;
        const bestLabel = describeHand(bestEval);
        const oppLabel = loser!=null ? describeHand(oppEval) : '';
        const resultEl = document.getElementById('result');
        const contId = 'res-continue';
        resultEl.style.display='block';
        try { resultEl.style.zIndex = '9999'; } catch{}
        if (!state.overlayShown) { state.overlayShown = true; }
        let msgHtml = (winners.length===2
          ? `Split Pot â ${bestLabel}`
          : `${winnerName} wins ${state.message ? state.message.replace(/.*wins\\s+/, '') : ''} with ${bestLabel}` + (loser!=null? `<br/><span style='font-weight:700;color:#93c5fd'>Beats ${state.players[loser].name}'s ${oppEval?describeHand(oppEval):''}</span>` : ''));
        if (state.gameOver) {
          msgHtml += `<br/><span style=\"color:#ef4444;font-weight:900;\">Game over! ${state.gameOverWinner} won the game!</span>`;
        }
        const controlsHtml = state.gameOver
          ? `<button id=\"res-replay\" class=\"res-btn\">Play again?</button>`
          : `<button id=\"${contId}\" class=\"res-btn\">Continue</button>`;
        resultEl.innerHTML = msgHtml + `<div style=\"margin-top:10px;display:flex;gap:10px;justify-content:center\">${controlsHtml}</div>`;
        updateControls(); draw();
        try { startShowdownWatchdog(); } catch{}
        let advanced=false; const proceed=()=>{
          if(advanced) return; advanced=true; resultEl.style.display='none';
          if(isMultiplayer){ try{ sendAction('continue'); }catch{} }
          try { stopShowdownWatchdog(); } catch{}
        };
        const btn=document.getElementById(contId); if(btn) btn.onclick=proceed;
        const replay=document.getElementById('res-replay');
        if(replay){ replay.onclick=()=>{ try{ sendAction('play_again'); }catch{} resultEl.style.display='none'; } }
        setTimeout(()=>{ if(!state.gameOver && btn) proceed(); }, 5000);
      }catch{}
    }

    // Simple overlay for fold outcome
    function showFoldOverlay(winnerId, prize){
      if (state.overlayShown) return;
      try{
        const resultEl = document.getElementById('result');
        const contId = 'res-continue';
        resultEl.style.display='block';
        try { resultEl.style.zIndex = '9999'; } catch{}
        if (!state.overlayShown) { state.overlayShown = true; }
        const winnerName = state.players[winnerId]?.name || 'Player';
        resultEl.innerHTML = `${winnerName} wins ${prize} (fold)` + `<div><button id=\"${contId}\" class=\"res-btn\">Continue</button></div>`;
        updateControls(); draw();
        try { startShowdownWatchdog(); } catch{}
        let advanced=false; const proceed=()=>{
          if(advanced) return; advanced=true; resultEl.style.display='none';
          if(state.players[0].stack<=0 || state.players[1].stack<=0){
            showLog('Game Over');
            return;
          }
          if(state.handAdvanced) return;
          state.handAdvanced = true;
          if(!isMultiplayer){
            resetHand();
          }
          try { stopShowdownWatchdog(); } catch{}
        };
        const btn=document.getElementById(contId); if(btn) btn.onclick=proceed;
        setTimeout(()=>{ proceed(); }, 5000);
      }catch{}
    }

    function playerFold(pid){
      if(isMultiplayer){
        // In multiplayer, we don't mutate state here. Send-only wrapper above will call sendAction.
        return;
      }
      state.players[pid].folded=true; const opp=1-pid; const prize=state.pot; state.players[opp].stack += prize; state.message=`${state.players[opp].name} wins ${prize}`; state.pot=0; state.street='showdown'; if(pid===1) showAIAction('folded'); updateControls(); draw();
      showFoldOverlay(opp, prize);
    }
    function playerCall(pid){
      if(isMultiplayer){
        // Server authoritative; do nothing here (send-only wrapper will handle)
        return;
      }
      console.log(`ORIGINAL playerCall: pid=${pid}, before state:`, {
        betThisRound: [...state.betThisRound],
        curBet: state.curBet,
        acted: [...state.acted],
        toAct: state.toAct
      });
      
      const need=toCall(pid); const p=state.players[pid]; const pay=Math.min(need, p.stack);
      console.log(`Call calculation: need=${need}, pay=${pay}, stack=${p.stack}`);
      
      p.stack-=pay; state.betThisRound[pid]+=pay; state.pot+=pay;
      state.curBet = Math.max(state.curBet, state.betThisRound[0], state.betThisRound[1]);
      state.acted[pid] = true;
      
      console.log(`After call: pid=${pid}, after state:`, {
        betThisRound: [...state.betThisRound],
        curBet: state.curBet,
        acted: [...state.acted],
        toAct: state.toAct,
        pot: state.pot
      });

      // Single-player: after a preflop call, always advance to flop to avoid stalls
      if(!isMultiplayer && state.street==='preflop'){
        state.acted = [true,true];
        endStreet();
        return;
      }
      
      // If an all-in has been called and bets are matched, immediately run out the board
      if(isAllInAndEqual()) { 
        console.log('All-in condition met, running out board');
        updateControls(); draw(); maybeAutoRunout(); return; 
      }
      
      const bothActed = bothActedAndEqual();
      console.log(`bothActedAndEqual() returned: ${bothActed}`);
      
      if(bothActed) { 
        console.log('Both players acted and equal, calling endStreet()');
        endStreet(); 
      } else { 
        console.log('Not both acted/equal, continuing play');
        state.toAct=nextPlayerAfter(pid);
        updateControls();
        draw();
        // If both have now acted with equal bets, close street
        if(bothActedAndEqual() || bothCheckedThisStreet()) { endStreet(); return; }
        if(!maybeAutoRunout() && !isMultiplayer && state.toAct===1 && !state.animating){ try { aiAct(); } catch { scheduleAI(0); } }
      }
      // Safety: if preflop bets are equal shortly after a call, auto-close street
      if(!isMultiplayer && state.street==='preflop'){
        setTimeout(()=>{ try{
          if(state.street==='preflop' && state.betThisRound[0]===state.betThisRound[1]){
            endStreet();
          }
        }catch{} }, 250);
      }
    }
    function playerBetOrRaise(pid, amount){
      if(isMultiplayer){
        // Server authoritative; do nothing here (send-only wrapper will handle)
        return;
      }
      const [minAmt, maxAmt]=openAmountRange(pid);
      const target = Math.max(minAmt, Math.min(amount, maxAmt));
      const p=state.players[pid]; const put = target - state.betThisRound[pid];
      const pay = Math.min(put, p.stack);
      p.stack-=pay; state.pot+=pay; state.betThisRound[pid]+=pay;
      state.curBet=Math.max(state.curBet, state.betThisRound[pid]);
      state.lastAggressor=pid; state.acted=[false,false]; state.acted[pid]=true; state.toAct=nextPlayerAfter(pid);
      // If this action results in all-in and matched bets, run out immediately
      if(isAllInAndEqual()) { updateControls(); draw(); maybeAutoRunout(); return; }
      // If opponent has zero stack (covered and called), runout
      if(state.players[1-pid].stack===0 && state.betThisRound[0]===state.betThisRound[1]){ updateControls(); draw(); maybeAutoRunout(); return; }
      updateControls(); draw(); if(!maybeAutoRunout()) maybeAIMove();
    }

    // Controls
    const foldBtn = document.getElementById('foldBtn');
    const checkCallBtn = document.getElementById('checkCallBtn');
    const halfBtn = document.getElementById('halfBtn');
    const potBtn = document.getElementById('potBtn');
    const allinBtn = document.getElementById('allinBtn');
    const betAmt = document.getElementById('betAmt');
    const betRaiseBtn = document.getElementById('betRaiseBtn');
    function showLog(msg){ const el=document.getElementById('log'); el.textContent=msg; el.style.display='block'; clearTimeout(showLog._t); showLog._t=setTimeout(()=>{ el.style.display='none'; }, 2200); }
    function showAIAction(text){ const el=document.getElementById('log'); el.textContent = `Your AI poker player ${text}`; el.style.display='block'; clearTimeout(showAIAction._t); showAIAction._t=setTimeout(()=>{ el.style.display='none'; }, 2000); }
    function updateControls(){
      const pid = isMultiplayer ? getMyId() : 0; 
      
      // In multiplayer, don't update controls until we have a valid assigned player ID
      if (isMultiplayer && (assignedPlayerId === null || pid === null)) {
        console.log('updateControls: waiting for assigned player ID', { assignedPlayerId, pid });
        const disableAll = true;
        foldBtn.disabled = disableAll;
        checkCallBtn.disabled = disableAll;
        halfBtn.disabled = disableAll; 
        potBtn.disabled = disableAll; 
        allinBtn.disabled = disableAll; 
        betRaiseBtn.disabled = disableAll;
        return;
      }
      
      const meTurn = state.toAct===pid && !state.players[pid].folded && state.street!=='showdown' && !state.animating;
      const callable = toCall(pid);
      
      console.log(`updateControls: myId=${pid}, toAct=${state.toAct}, meTurn=${meTurn}, assignedPlayerId=${assignedPlayerId}`);
      console.log(`Game state:`, {
        street: state.street,
        curBet: state.curBet,
        betThisRound: state.betThisRound,
        callable: callable,
        playerChips: state.players.map(p => p.chips),
        playerBets: state.players.map(p => p.bet),
        acted: state.acted,
        dealer: state.dealer,
        isMyTurn: meTurn
      });
      
      // Log blind positions for debugging
      if (state.street === 'preflop') {
        console.log(`Preflop positions: Dealer=${state.dealer} (small blind), Big blind=${1-state.dealer}, First to act=${state.toAct}`);
      }
      
      const disableAll = state.animating || state.street==='showdown';
      foldBtn.disabled = disableAll || !meTurn;
      checkCallBtn.textContent = callable>0 ? `Call ${callable}` : 'Check';
      checkCallBtn.disabled = disableAll || !meTurn;
      const [minAmt,maxAmt] = openAmountRange(pid);
      betAmt.value = Math.min(Math.max(Number(betAmt.value)||minAmt, minAmt), maxAmt);
      halfBtn.disabled = disableAll || !meTurn; potBtn.disabled = disableAll || !meTurn; allinBtn.disabled = disableAll || !meTurn; betRaiseBtn.disabled = disableAll || !meTurn;
      betRaiseBtn.textContent = state.curBet>0? 'Raise' : 'Bet';

      // In single-player, if it's AI's turn now and we're not animating, act immediately
      if (!isMultiplayer && state.toAct===1 && !state.animating && state.street!=='showdown') {
        try { aiAct(); } catch { scheduleAI(0); }
      }
    }
    foldBtn.addEventListener('click', ()=>{ 
      const myId = isMultiplayer ? getMyId() : 0; 
      if(state.toAct!==myId) return; 
      playerFold(myId); 
    });
    checkCallBtn.addEventListener('click', ()=>{ 
      const myId = isMultiplayer ? getMyId() : 0; 
      console.log(`Check/Call button clicked: myId=${myId}, toAct=${state.toAct}, isMyTurn=${state.toAct===myId}`);
      
      if(isMultiplayer && state.toAct!==myId) {
        console.log('Not my turn (multiplayer), ignoring click');
        return; 
      }
      
      const need=toCall(myId); 
      console.log(`Amount needed to call: ${need}`);
      
      if(need>0) {
        console.log('Calling with amount:', need);
        playerCall(myId); 
        // playerCall wrapper will send action after state changes
      } else { 
        console.log('Checking (no amount to call)');
        if (isMultiplayer) { 
          sendAction('check'); 
          return; 
        }
        state.acted[myId]=true; 
        if(bothActedAndEqual() || bothCheckedThisStreet()) { 
          endStreet(); 
          return; 
        } else { 
          state.toAct = myId === 0 ? 1 : 0; 
          updateControls(); 
          draw(); 
          if(!isMultiplayer && state.toAct===1 && !state.animating){
            try { aiAct(); } catch { scheduleAI(0); }
          } else {
            maybeAIMove();
          }
        } 
      }
    });
    halfBtn.addEventListener('click', ()=>{ 
      const myId = isMultiplayer ? getMyId() : 0; 
      if(state.toAct!==myId) return; 
      const potHalf = Math.max(BIG_BLIND, Math.round((state.pot + toCall(myId) + state.betThisRound[0] + state.betThisRound[1]) * 0.5)); 
      betAmt.value = potHalf; 
    });
    potBtn.addEventListener('click', ()=>{ 
      const myId = isMultiplayer ? getMyId() : 0; 
      if(state.toAct!==myId) return; 
      const potSize = state.pot + toCall(myId) + state.betThisRound[0] + state.betThisRound[1]; 
      betAmt.value = Math.max(BIG_BLIND, potSize); 
    });
    allinBtn.addEventListener('click', ()=>{ 
      const myId = isMultiplayer ? getMyId() : 0; 
      if(state.toAct!==myId) return; 
      betAmt.value = allInCap(myId); 
    });
    betRaiseBtn.addEventListener('click', ()=>{ 
      const myId = isMultiplayer ? getMyId() : 0; 
      if(state.toAct!==myId) return; 
      const amt = Number(betAmt.value)||0; 
      playerBetOrRaise(myId, amt); 
    });

    // AI Decision (Monte Carlo + heuristics)
    let aiTimer = null;
    function aiForceAct(){
      try{
        const need = toCall(1);
        if(need>0){ playerCall(1); }
        else {
          state.acted[1]=true;
          if(bothActedAndEqual() || bothCheckedThisStreet()) endStreet();
          else { state.toAct=0; updateControls(); draw(); }
        }
      }catch{}
    }
    function scheduleAI(delay){ if(aiTimer) { try{ clearTimeout(aiTimer); }catch{} aiTimer=null; } aiTimer = setTimeout(()=>{ aiTimer=null; if(!isMultiplayer && state.toAct===1 && !state.players[1].folded && state.street!=='showdown' && !state.animating) { try{ aiAct(); }catch(e){ console.error('aiAct error, forcing simple action', e); aiForceAct(); } } }, delay); }
    function maybeAIMove(){ if(state.toAct!==1 || state.players[1].folded || state.street==='showdown') return; scheduleAI(150 + Math.random()*200); }
    // Preflop strength heuristic 0..1 for all-in discipline
    function preflopScore(hole){
      if(!hole || hole.length<2) return 0;
      const r1 = hole[0].r, r2 = hole[1].r; const hi = Math.max(r1,r2), lo = Math.min(r1,r2);
      const suited = hole[0].s === hole[1].s;
      const gap = Math.abs(r1 - r2) - 1;
      let score;
      if(hi===lo){
        score = 0.84 + (hi-2)*0.01; // 22 ~0.84 .. AA ~0.97
      } else {
        score = (hi/14)*0.45 + (lo/14)*0.25;
        if(suited) score += 0.06;
        if(gap<=0) score += 0.05; else if(gap===1) score += 0.03; else if(gap>=3) score -= 0.06;
        if(hi===14 && lo>=10) score += 0.04;
      }
      return Math.max(0, Math.min(1, score));
    }
    function aiAct(){
      const pid=1; const me=state.players[pid]; const hero=state.players[0];
      const need = toCall(pid);
      if(me.stack===0){ 
        state.acted[pid] = true;
        if(bothActedAndEqual() || bothCheckedThisStreet()) endStreet(); 
        else { state.toAct=0; updateControls(); draw(); if(!maybeAutoRunout()) maybeAIMove(); } 
        return; 
      }
      const potNow = state.pot;
      const isFacingAllIn = need >= me.stack;
      const iters = isFacingAllIn ? 3500 : (state.street==='river'? 1200 : state.street==='turn'? 900 : state.street==='flop'? 700 : 600);
      const eq = estimateEquity(me.hole, state.board, hero.hole, iters);
      const minR = openAmountRange(pid)[0];
      const posAdv = (state.dealer===pid && (state.street==='flop'||state.street==='turn'||state.street==='river')) ? 0.02 : 0.0;
      // Slightly lower thresholds to increase overall aggression without going wild
      const strong = eq > (0.58 - posAdv);
      const medium = eq > (0.46 - posAdv);
      const weak = eq < (0.36 - posAdv);
      const rnd = Math.random();
      if(need>0){
        const potOdds = need / Math.max(1, (potNow + need));
        let edge = state.street==='preflop'? 0.07 : state.street==='flop'? 0.045 : state.street==='turn'? 0.03 : 0.02;
        if(isFacingAllIn) edge += 0.03;
        if(state.street==='preflop' && isFacingAllIn){
          const pf = preflopScore(me.hole);
          if(pf < 0.55){ playerFold(pid); return; }
        }
        const mustHave = potOdds + edge;
        if(eq < mustHave){ playerFold(pid); return; }
        // Raise more often: with strong hands frequently, with medium sometimes, and occasional bluff raises with good odds
        if(!isFacingAllIn && me.stack>minR){
          if(strong && rnd < 0.65){
            const mult = state.street==='preflop'? 3.0 : state.street==='flop'? 2.2 : 1.7;
            const size = Math.min(allInCap(pid), Math.max(minR, Math.round((need + potNow) * (mult*0.35))));
            playerBetOrRaise(pid, size); showAIAction(`raised ${size}`); return;
          }
          if(medium && rnd < 0.25){
            const size = Math.min(allInCap(pid), Math.max(minR, Math.round((potNow + need) * 0.6)));
            playerBetOrRaise(pid, size); showAIAction(`raised ${size}`); return;
          }
          if(!weak && potOdds < 0.28 && rnd < 0.15){
            const size = Math.min(allInCap(pid), Math.max(minR, Math.round((potNow + need) * 0.55)));
            playerBetOrRaise(pid, size); showAIAction(`raised ${size}`); return;
          }
        }
        playerCall(pid); showAIAction(`called ${need}`); if(isAllInAndEqual()) { updateControls(); draw(); maybeAutoRunout(); } return;
      } else {
        const base = state.street==='preflop'? 5 : state.street==='flop'? Math.round(potNow*0.66) : Math.round(potNow*0.55);
        // Continuation betting: if AI was last aggressor, bet more frequently even without strong equity
        const wasAggressor = state.lastAggressor === pid;
        const cbetChance = state.street==='flop' ? 0.55 : state.street==='turn' ? 0.40 : state.street==='river' ? 0.28 : 0.0;
        if(strong){
          const size = Math.min(allInCap(pid), Math.max(minR, base));
          playerBetOrRaise(pid, size); showAIAction(`bet ${size}`); return;
        }
        const smallBluffChance = state.street==='river'? 0.06 : 0.18;
        if(medium && rnd<0.40){
          const size = Math.min(allInCap(pid), Math.max(minR, Math.round(base*0.7)));
          playerBetOrRaise(pid, size); showAIAction(`bet ${size}`); return;
        } else if((!weak && rnd<smallBluffChance) || (wasAggressor && rnd < cbetChance)){
          const size = Math.min(allInCap(pid), Math.max(minR, Math.round(base*0.5)));
          playerBetOrRaise(pid, size); showAIAction(`bet ${size}`); return;
        }
        state.acted[pid] = true; showAIAction('checked');
        if(bothActedAndEqual() || bothCheckedThisStreet()) { endStreet(); }
        else { state.toAct=0; updateControls(); draw(); if(!maybeAutoRunout()) maybeAIMove(); }
      }
    }
    function meTurned(){ state.acted[1]=true; }
    function showLog(msg){ const el=document.getElementById('log'); el.textContent=msg; el.style.display='block'; clearTimeout(showLog._t); showLog._t=setTimeout(()=>{ el.style.display='none'; }, 2200); }

    // Multiplayer functions
    function initMultiplayer() {
      // Close existing connection if any
      if (gameWs && gameWs.readyState !== WebSocket.CLOSED) {
        console.log('Closing existing WebSocket connection');
        gameWs.close();
      }
      
      // Connect to Cloudflare Worker game WebSocket
      const workerUrl = 'poker-multiplayer.xiachen.workers.dev';
      const protocol = 'wss:';
      const wsUrl = `${protocol}//${workerUrl}/game/${gameId}`;
      
      console.log('Creating new WebSocket connection to:', wsUrl);
      gameWs = new WebSocket(wsUrl);
      
      gameWs.onopen = function() {
        console.log('Connected to game WebSocket');
        console.log('Sending join_game message:', {
          type: 'join_game',
          gameId: gameId,
          playerId: myPlayerId,
          playerName: myPlayerName
        });
        gameWs.send(JSON.stringify({
          type: 'join_game',
          gameId: gameId,
          playerId: myPlayerId,
          playerName: myPlayerName
        }));
        
        // Start heartbeat to keep Worker alive
        startHeartbeat();
      };
      
      gameWs.onmessage = function(event) {
        console.log('Received game message:', event.data);
        const data = JSON.parse(event.data);
        handleGameMessage(data);
      };
      
      gameWs.onclose = function(event) {
        console.log('Game WebSocket closed:', {
          code: event.code,
          reason: event.reason,
          wasClean: event.wasClean,
          timestamp: new Date().toISOString()
        });
        
        // Check if this is a Worker suspension (code 1001) and try to reconnect
        if (event.code === 1001 || event.reason?.includes('suspension')) {
          console.log('Worker suspended, attempting reconnection...');
          showLog('Connection lost due to server suspension. Reconnecting...');
          
          // Try to reconnect after a short delay
          setTimeout(() => {
            if (isMultiplayer && gameId && myPlayerId) {
              console.log('Attempting to reconnect to game...');
              initMultiplayer();
            }
          }, 2000);
        } else if (event.code === 1006) {
          // Unexpected disconnection - also try to reconnect
          console.log('Unexpected disconnection, attempting reconnection...');
          showLog('Connection lost unexpectedly. Reconnecting...');
          
          setTimeout(() => {
            if (isMultiplayer && gameId && myPlayerId) {
              console.log('Attempting to reconnect after unexpected disconnection...');
              initMultiplayer();
            }
          }, 3000);
        } else if (event.code !== 1000) { // 1000 = normal closure
          showLog('Connection lost. Redirecting to lobby...');
          setTimeout(() => {
            window.location.href = 'lobby.html';
          }, 3000);
        }
        
        // Stop heartbeat when connection closes
        stopHeartbeat();
      };
      
      gameWs.onerror = function(error) {
        console.error('Game WebSocket error:', error);
      };
    }
    
    function handleGameMessage(data) {
      switch(data.type) {
        case 'game_state':
          if (data.state) {
            console.log('Applying server-authoritative game_state');
            const myId = assignedPlayerId ?? 0;
            const oppId = 1 - myId;
            const myName = state.players[myId]?.name || (decodeURIComponent(myPlayerName)||'You');
            const oppName = state.players[oppId]?.name || (decodeURIComponent(opponentName)||'Opponent');
            // Copy full state from server
            if (typeof data.state.handId === 'number') state.handId = data.state.handId;
            if (typeof data.state.dealer === 'number') state.dealer = data.state.dealer;
            state.pot = Number(data.state.pot||0);
            state.curBet = Number(data.state.curBet||0);
            state.toAct = typeof data.state.toAct==='number' ? data.state.toAct : 0;
            state.street = data.state.street || 'preflop';
            if (Array.isArray(data.state.players) && data.state.players.length===2) {
              for (let i=0;i<2;i++){
                state.players[i].stack = Number(data.state.players[i]?.stack ?? state.players[i].stack);
                state.players[i].folded = !!data.state.players[i]?.folded;
                // Copy holes as provided by server view (opponent may be masked before showdown)
                state.players[i].hole = Array.isArray(data.state.players[i]?.hole) ? JSON.parse(JSON.stringify(data.state.players[i].hole)) : [];
              }
            }
            state.board = Array.isArray(data.state.board) ? JSON.parse(JSON.stringify(data.state.board)) : [];
            state.betThisRound = Array.isArray(data.state.betThisRound) ? [Number(data.state.betThisRound[0]||0), Number(data.state.betThisRound[1]||0)] : [0,0];
            state.acted = Array.isArray(data.state.acted) ? [!!data.state.acted[0], !!data.state.acted[1]] : [false,false];
            state.gameOver = !!data.state.gameOver;
            state.gameOverWinner = data.state.gameOverWinner || '';
            // Names from our perspective
            state.players[myId].name = myName; state.players[oppId].name = oppName;
            // Reveal flags aligned to street for consistent rendering
            if (state.street === 'preflop') {
              state.revealed.human = 2; state.revealed.ai = 0; state.revealed.board = 0;
            } else if (state.street === 'flop') {
              state.revealed.human = 2; state.revealed.ai = 0; state.revealed.board = Math.max(state.revealed.board, 3);
            } else if (state.street === 'turn') {
              state.revealed.human = 2; state.revealed.ai = 0; state.revealed.board = Math.max(state.revealed.board, 4);
            } else if (state.street === 'river') {
              state.revealed.human = 2; state.revealed.ai = 0; state.revealed.board = Math.max(state.revealed.board, 5);
            } else if (state.street === 'showdown') {
              state.revealed.human = 2; state.revealed.ai = 2; state.revealed.board = 5;
            }
            // Reset overlay flags when not in showdown so the next result can display
            if (state.street !== 'showdown') {
              try {
                state.overlayShown = false;
                state.handAdvanced = false;
                const resultEl = document.getElementById('result');
                if (resultEl) resultEl.style.display = 'none';
              } catch {}
            }
            state.animating = false; state.glAnimating = false;
            updateControls(); draw();
            if (state.street === 'showdown') {
              try { showPassiveShowdownOverlay(); } catch{}
            }
          }
          break;
        case 'game_ready':
          // Set assigned player ID from server
          if (data.myPlayerId !== undefined) {
            assignedPlayerId = data.myPlayerId;
            console.log(`Server assigned me player ID: ${assignedPlayerId}`);
          }
          
          // Set opponent info and start game
          if (data.opponent) {
            opponentName = data.opponent.name;
            
            // In multiplayer, each player should see themselves in their own position
            // Update names so each player sees "You" for themselves and opponent name for opponent
            const myName = decodeURIComponent(myPlayerName) || 'You';
            const oppName = opponentName || 'Opponent';
            
            if (assignedPlayerId === 0) {
              // I am player 0, opponent is player 1
              state.players[0].name = myName;
              state.players[1].name = oppName;
            } else {
              // I am player 1, opponent is player 0  
              state.players[0].name = oppName;
              state.players[1].name = myName;
            }
            
            console.log(`Names set: Player 0 = ${state.players[0].name}, Player 1 = ${state.players[1].name}`);
          }
          console.log(`Game ready with ${data.playersConnected} players, I am player ${assignedPlayerId}`);
          
          // Server-authoritative: do not locally start/sync; wait for game_state frames
          
          updateControls();
          draw();
          break;
        case 'opponent_action':
          // Deprecated in server-authoritative flow; ignore
          break;
        case 'game_ended':
          showLog(`Game ended: ${data.reason}`);
          // Only redirect if it's a disconnect, not normal game end
          if (data.reason === 'Opponent disconnected') {
            setTimeout(() => {
              window.location.href = 'lobby.html';
            }, 5000);
          }
          break;
        case 'error':
          showLog(`Error: ${data.message}`);
          break;
        case 'pong':
          // Heartbeat response - connection is alive
          console.log('Received pong response');
          break;
      }
    }
    
    // Deprecated: opponent_action/state-sync logic removed (server-authoritative now)
    
    function getMyId() {
      // In multiplayer, use the ID assigned by the server
      if (!isMultiplayer) return 0;
      
      // Use the assigned player ID from the server
      const myId = assignedPlayerId !== null ? assignedPlayerId : 0;
      console.log(`getMyId() returning: ${myId} (assignedPlayerId: ${assignedPlayerId})`);
      return myId;
    }
    
    function getOpponentId() {
      return 1 - getMyId();
    }
    
    function validateAndFixGameState() {
      console.log('Validating game state...');
      
      // Ensure basic state properties exist
      if (!state.players || state.players.length !== 2) {
        console.error('Invalid players state');
        return;
      }
      
      if (typeof state.toAct !== 'number' || state.toAct < 0 || state.toAct > 1) {
        console.warn('Invalid toAct, setting to 0');
        state.toAct = 0;
      }
      
      if (!Array.isArray(state.betThisRound) || state.betThisRound.length !== 2) {
        console.warn('Invalid betThisRound, initializing');
        state.betThisRound = [0, 0];
      }
      
      if (!Array.isArray(state.acted) || state.acted.length !== 2) {
        console.warn('Invalid acted array, initializing');
        state.acted = [false, false];
      }
      
      if (typeof state.curBet !== 'number' || state.curBet < 0) {
        console.warn('Invalid curBet, setting to 0');
        state.curBet = 0;
      }
      
      // Ensure consistent bet state
      for (let i = 0; i < 2; i++) {
        if (typeof state.players[i].chips !== 'number') {
          console.warn(`Player ${i} has invalid chips`);
          state.players[i].chips = 1000; // Default
        }
        if (typeof state.players[i].bet !== 'number') {
          console.warn(`Player ${i} has invalid bet`);
          state.players[i].bet = 0;
        }
        if (typeof state.betThisRound[i] !== 'number') {
          console.warn(`Player ${i} has invalid betThisRound`);
          state.betThisRound[i] = 0;
        }
      }
      
      console.log('Game state validation complete');
      
      // Additional debugging for blind positions
      if (state.street === 'preflop') {
        console.log(`POST-VALIDATION Preflop: dealer=${state.dealer}, toAct=${state.toAct}, betThisRound=[${state.betThisRound}]`);
      }
    }
    
    function sendAction(actionType, amount = null) {
      if (!isMultiplayer || !gameWs || gameWs.readyState !== WebSocket.OPEN) {
        return;
      }
      
      const action = {
        type: 'player_action',
        gameId: gameId,
        playerId: myPlayerId,
        action: {
          type: actionType,
          amount: amount
        }
      };
      
      console.log(`Sending action ${actionType}`);
      gameWs.send(JSON.stringify(action));
    }
    
    // Heartbeat functions to keep Worker alive
    function startHeartbeat() {
      // Clear any existing heartbeat
      if (heartbeatInterval) {
        clearInterval(heartbeatInterval);
      }
      
      // Send ping every 25 seconds to prevent Worker suspension
      heartbeatInterval = setInterval(() => {
        if (gameWs && gameWs.readyState === WebSocket.OPEN) {
          console.log('Sending heartbeat ping');
          gameWs.send(JSON.stringify({
            type: 'ping',
            timestamp: Date.now()
          }));
        }
      }, 25000);
      
      console.log('Heartbeat started - sending ping every 25 seconds');
    }
    
    function stopHeartbeat() {
      if (heartbeatInterval) {
        clearInterval(heartbeatInterval);
        heartbeatInterval = null;
        console.log('Heartbeat stopped');
      }
    }
    
    // Override AI move for multiplayer
    function maybeAIMove() {
      if (isMultiplayer) {
        console.log('Multiplayer mode: no AI move, waiting for human opponent');
        // In multiplayer, no AI - just wait for opponent's action
        return;
      }
      
      // Original AI logic for single player mode
      console.log('Single-player mode: scheduling AI move');
      if(state.toAct!==1 || state.players[1].folded || state.street==='showdown') return; 
      scheduleAI(150 + Math.random()*200);
    }
    
    // Override player actions in multiplayer: send-only; let server drive state
    const originalPlayerFold = playerFold;
    const originalPlayerCall = playerCall;
    const originalPlayerBetOrRaise = playerBetOrRaise;
    if(isMultiplayer){
      playerFold = function(pid){ if(pid!==getMyId()) return; sendAction('fold'); };
      playerCall = function(pid){ if(pid!==getMyId()) return; sendAction('call'); };
      playerBetOrRaise = function(pid, amount){ if(pid!==getMyId()) return; sendAction('bet_raise', amount); };
    }
    
    // Update player names for multiplayer
    function getPlayerName(pid) {
      if (!isMultiplayer) {
        return pid === 0 ? 'You' : 'AI';
      }
      
      if (pid === getMyId()) {
        return decodeURIComponent(myPlayerName) || 'You';
      } else {
        return decodeURIComponent(opponentName) || 'Opponent';
      }
    }

    // Add global error handler for debugging
    window.addEventListener('error', function(event) {
      console.error('JavaScript error:', event.error);
      if (isMultiplayer && gameWs) {
        console.log('WebSocket state after error:', {
          readyState: gameWs.readyState,
          url: gameWs.url
        });
      }
    });

    // Add unhandled promise rejection handler
    window.addEventListener('unhandledrejection', function(event) {
      console.error('Unhandled promise rejection:', event.reason);
    });

    resize();
    // Start a hand only in single-player here. In multiplayer, the game master will start it after both players are ready
    if (!isMultiplayer) {
      resetHand();
    }
    // Expose debug helpers for console inspection
    try{
      window.poker = {
        get state(){ return state; },
        endStreet, bothActedAndEqual, bothCheckedThisStreet, toCall,
        scheduleAI, aiAct, playerCall, playerBetOrRaise, updateControls
      };
    }catch{}
  })();
  </script>
</body>
</html>



<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover">
  <title>Arcade Football</title>
  <style>
    :root {
      --bg: linear-gradient(135deg, #0f172a, #0b1220);
      --panel: rgba(14,23,42,0.9);
      --border: #334155;
      --text: #e2e8f0;
      --muted: #93c5fd;
      --accent1: #60a5fa;
      --accent2: #a78bfa;
      --turf: #0b5c2a;
      --turf-dark: #094d23;
      --line: #e2e8f0;
      --offense: #38bdf8;
      --defense: #f97316;
      --ball: #a0522d;
    }
    html, body { height: 100%; margin: 0; font-family: 'Segoe UI', Arial, sans-serif; background: var(--bg); color: var(--text); }
    .wrap { min-height: 100%; display: grid; grid-template-rows: auto 1fr auto; }
    header { display: flex; align-items: center; gap: 12px; padding: calc(10px + env(safe-area-inset-top)) 16px 12px 16px; background: var(--panel); border-bottom: 1px solid var(--border); }
    header a { color: var(--muted); text-decoration: none; font-weight: 700; }
    main { position: relative; }
    #hud { display: none; }
    #controls { display: none; }
    canvas { width: 100vw; height: calc(100vh - 64px); display: block; background: repeating-linear-gradient(90deg, var(--turf), var(--turf) 40px, var(--turf-dark) 40px, var(--turf-dark) 80px); touch-action: none; }
    footer { padding: 10px; color: #94a3b8; text-align: center; }
    .btn { padding: 8px 12px; border-radius: 10px; border: 2px solid #475569; background: linear-gradient(135deg, #1e293b, #334155); color: var(--text); font-weight: 700; text-decoration: none; }
    .padbtn, .actbtn { width: 58px; height: 58px; background: rgba(30,41,59,.8); border: 2px solid #475569; border-radius: 12px; color: var(--text); font-weight: 800; font-size: 16px; }
    .actbtn { width: 140px; height: 50px; font-size: 15px; }
    .padbtn:active, .actbtn:active { transform: translateY(1px); }
    @media (max-width: 820px) {
      #dock { left: 50% !important; right: auto !important; bottom: calc(80px + env(safe-area-inset-bottom)) !important; transform: translateX(-50%) !important; gap: 16px !important; }
      #pad { grid-template-columns:58px 58px 58px !important; grid-template-rows:58px 58px 58px !important; gap:8px !important; }
      .padbtn { width: 58px; height: 58px; font-size: 16px; }
    }
  </style>
</head>
<body>
  
  <div class="wrap">
    <header>
      <a href="games.html">← All Games</a>
      <div style="flex:1"></div>
      <div>Fruity Football</div>
    </header>
    <main>
      <canvas id="field" width="960" height="560"></canvas>
      <div id="hud">1st & 10 | Ball on 25 | 00:45</div>
      <div id="controls">
        WASD/Arrows: move • Shift: sprint • Space: snap • Mouse: aim pass • Click: throw<br>
        C: change receiver • R: reset play
      </div>
      <div id="announce" style="position:absolute;left:50%;top:18px;transform:translateX(-50%);background:rgba(0,0,0,.35);border:2px solid rgba(248,113,113,.55);padding:10px 16px;border-radius:14px;font-weight:900;letter-spacing:1px;display:none;text-align:center;max-width:90%"></div>
      <div id="dock" style="position:absolute;left:50%;bottom:calc(14px + env(safe-area-inset-bottom));transform:translateX(-50%);display:flex;align-items:center;gap:16px;user-select:none;touch-action:none">
        <div id="pad" style="display:grid;grid-template-columns:58px 58px 58px;grid-template-rows:58px 58px 58px;gap:8px">
          <div></div>
          <button data-key="ArrowUp" class="padbtn">W</button>
          <div></div>
          <button data-key="ArrowLeft" class="padbtn">A</button>
          <div></div>
          <button data-key="ArrowRight" class="padbtn">D</button>
          <div></div>
          <button data-key="ArrowDown" class="padbtn">S</button>
          <div></div>
        </div>
        <button id="panicBtn" class="actbtn" style="display:none; width: 120px; height: 50px; font-size: 12px; background: linear-gradient(135deg, #dc2626, #b91c1c); border: 2px solid #991b1b; color: white;">PANIC!</button>
      </div>
    </main>
    <footer>
      <a class="btn" href="games.html">Back</a>
    </footer>
  </div>
  <script>
  (function(){
    const DPR = Math.min(2, window.devicePixelRatio || 1);
    const canvas = document.getElementById('field');
    const ctx = canvas.getContext('2d');
    let W = canvas.clientWidth, H = canvas.clientHeight;
    const hud = document.getElementById('hud');

    // Game constants
    const FIELD_LEN_YARDS = 100;
    const YARDS_PER_LINE = 10; // hash every 10 yds
    let PX_PER_YARD = (H - 60) / FIELD_LEN_YARDS;
    let LEFT_HASH = 80, RIGHT_HASH = W - 80;

    const PLAYER_R = 18; // px (larger)
    let DEFENDER_R = 22; // 20% larger (scaled on mobile)
    const BALL_R = 9;
    const CONTACT_PAD = 8; // require visible overlap before tackle triggers
    let CARRIER_MULT = 3.0; // ball carrier speed multiplier (uniform across devices)

    const BASE_SPEED = 0.6; // px/frame (slightly faster pace)
    const SPRINT_MULT = 1.2;
    const DEF_SPEED = 0.62; // defense tuned to keep up fairly
    const PASS_SPEED = 2.4; // slower passes
    let ACCEL = 0.12;      // player acceleration smoothing (mobile override in resize)
    const DEF_ACCEL = 0.10;  // defender acceleration smoothing
    const TACKLE_HOLD_MS = 180; // must maintain contact this long to tackle
    const DEF_REACT_MIN_MS = 120;
    const DEF_REACT_MAX_MS = 220;
    const PASS_LEAD = 12; // defenders lead prediction
    const INTERCEPT_LEAD = 10;
    const CONTAIN_MARGIN_X = 70;
    const LEAF_SPEED = 4.5; // px/frame for fruit projectiles (50% faster)
    const PLAYER_SPEED_BONUS = 1.5; // +50% player speed globally

    // State
    const state = {
      clockMs: 45_000,
      down: 1,
      distance: 75, // yards to touchdown (100 - 25 starting yard line)
      ballOnYard: 25,
      possession: 'human',
      playActive: false,
      snapped: false,
      gameOver: false,
      level: 1,
      newLevelShow: true,
      hasBall: 'qb', // 'qb' or receiver index
      ballPos: {x: (LEFT_HASH+RIGHT_HASH)/2, y: yardToY(25)},
      ballVel: {x:0,y:0},
      qb: {x: (LEFT_HASH+RIGHT_HASH)/2, y: yardToY(23), vx:0, vy:0, stamina: 100},
       receivers: [],
       activeReceiver: 0,
      defenders: [],
      tackling: false,
      scored: false,
      sprint: false,
      // short burst ability
      dashMs: 0,
      dashCooldownMs: 0,
      dashVec: { vx: 0, vy: 1 },
      dashing: false,
      // panic button ability
      panicMs: 0,
      panicCooldownMs: 0,
      panicVec: { vx: 0, vy: 0 },
      panicking: false,
      panicBtnVisible: false,
      lastPanicCheck: 0,
      // background music
      bgMusicSource: null,
      bgMusicGain: null,
      bgMusicPlaying: false,
      projectiles: [],
      levelIntroMs: 0,
      mouse: {x: W/2, y:H/2},
      lastMoveDir: {x:0, y:-1},
      boostMs: 0,
      boostCooldownMs: 0,
    };

    function yardToY(yard){
      return H - 30 - yard * PX_PER_YARD;
    }
    function yToYard(y){
      return Math.round((H - 30 - y)/PX_PER_YARD);
    }

    function resetPlay(newSpot){
      if(state.gameOver) return;
      state.playActive = false;
      state.snapped = false;
      state.tackling = false;
      state.scored = false;
      state.hasBall = 'qb';
      state.projectiles = [];
      // Reset panic button state
      state.panicking = false;
      state.panicMs = 0;
      state.panicBtnVisible = false;
      document.getElementById('panicBtn').style.display = 'none';
      // Stop background music
      stopBgMusic();
      if(typeof newSpot === 'number') state.ballOnYard = Math.max(1, Math.min(99, newSpot));
      state.lineOfScrimmageYard = state.ballOnYard;
      const cx = (LEFT_HASH+RIGHT_HASH)/2;
      state.qb.x = cx; state.qb.y = yardToY(state.ballOnYard-2);
      state.qb.vx = state.qb.vy = 0; state.qb.stamina = 100;
      const yBase = state.qb.y - 30;
      state.receivers = [];
      state.activeReceiver = 0;
      spawnDefenders();
      placeBallOnQB();
      updateHud();
      if(state.pendingNextLevel){ state.level = state.pendingNextLevel; state.pendingNextLevel = 0; }
      if(!state.snapped){ try{ showLevelIntro(); }catch{} }
    }

    function placeBallOnQB(){
      state.ballPos.x = state.qb.x; state.ballPos.y = state.qb.y-8;
      state.ballVel.x = state.ballVel.y = 0;
    }

    function spawnDefenders(){
      const defenders = [];
      // Build fruit roster: 3 banana, 3 apple, 3 orange, 2 pear
      const isMobile = W <= 820;
      const base = isMobile
        ? ['apple','banana','orange','pear','apple']
        : [
            ...Array(3).fill('banana'),
            ...Array(3).fill('apple'),
            ...Array(3).fill('orange'),
            ...Array(2).fill('pear')
          ];
      // Add one extra fruit every 3 levels (very slow ramp), capped
      const extra = Math.min(3, Math.floor(Math.max(0, (state.level||1) - 1) / 3));
      const fruits = base.concat(Array(extra).fill(isMobile ? 'apple' : 'banana'));
      // Dynamic spacing based on field position: farther when far from end zone, closer when near
      const yardsToTD = Math.max(0, 100 - state.ballOnYard);
      const t = Math.max(0, Math.min(1, yardsToTD / 80)); // 1 far, 0 near goal
      const aheadMin = 110 + (200 - 110) * t;   // px ahead of QB minimum
      const aheadMax = 180 + (340 - 180) * t;   // px ahead of QB maximum
      const minSpawnDist = 90 + (160 - 90) * t; // px minimal radial distance from QB
      const cy = state.qb.y;
      for(const f of fruits){
        let attempts = 0;
        let x = 40 + Math.random()*(W-80);
        let y = Math.max(30, cy - (aheadMin + Math.random()*(aheadMax - aheadMin)));
        // Ensure minimum distance from QB so they are not too close initially
        while(Math.hypot(x - state.qb.x, y - state.qb.y) < minSpawnDist && attempts < 8){
          x = 40 + Math.random()*(W-80);
          y = Math.max(30, cy - (aheadMin + Math.random()*(aheadMax - aheadMin)));
          attempts++;
        }
        const iconFor = { banana:'🍌', apple:'🍎', orange:'🍊', pear:'🍐' };
        const speedFor = { banana:1.0, apple:1.35, orange:1.08, pear:0.98 };
        defenders.push({ x, y, vx:0, vy:0, role:'cover', type:f, icon: iconFor[f], speedMult: speedFor[f], burst:0, burstCooldown:0 });
      }
      state.defenders = defenders;
    }

    function yardsText(y){
      const v = Math.max(0, Number.isFinite(y) ? y : 0);
      return String(Math.round(v));
    }
    function updateHud(){
      const clock = Math.max(0, Math.floor(state.clockMs/1000));
      const mm = String(Math.floor(clock/60)).padStart(2,'0');
      const ss = String(clock%60).padStart(2,'0');
      hud.textContent = `${ordinal(state.down)} & ${yardsText(state.distance)} | Ball on ${Math.round(state.ballOnYard)} | ${mm}:${ss}`;
    }
    function ordinal(n){ return ['','1st','2nd','3rd'][n] || `${n}th`; }

    // Input
    const keys = new Set();
    function startPlay(){
      if(state.gameOver) return;
      if(state.levelIntroMs>0) return; // wait for level intro to finish
      if(!state.snapped){
        // clear any lingering projectiles from prior down
        try{ state.projectiles = []; }catch(_){ state.projectiles = []; }
        state.playActive = true; state.snapped = true;
        state.playStartMs = performance.now();
        playWhistle();
        announceDown();
        // Start background music when play begins
        startBgMusic();
      }
    }

    window.addEventListener('keydown', (e)=>{
      const handledKeys = ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d','W','A','S','D',' ' ,'Shift','c','C','e','E','r','R','b','B'];
      if(handledKeys.includes(e.key)) e.preventDefault();
      keys.add(e.key);
      // Start automatically when any movement key is pressed
      const movementKeys = ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d','W','A','S','D'];
      if(movementKeys.includes(e.key) && !state.snapped){ startPlay(); }
      if(e.key===' ') { startPlay(); }
      if(e.key==='c' || e.key==='C') state.activeReceiver = (state.activeReceiver+1)%state.receivers.length;
      if(e.key==='e' || e.key==='E') tryDash();
      if(e.key==='b' || e.key==='B') tryBoost();
      if(e.key==='r' || e.key==='R') { state.gameOver = false; resetPlay(25); }
    });
    window.addEventListener('keyup', (e)=>{
      keys.delete(e.key);
    });
    canvas.addEventListener('mousemove', (e)=>{
      const rect = canvas.getBoundingClientRect();
      state.mouse.x = (e.clientX - rect.left) * (canvas.width/rect.width);
      state.mouse.y = (e.clientY - rect.top) * (canvas.height/rect.height);
    });
    let isTouchAiming = false; let aimPoint = {x:0,y:0};
    // Shared timer for temporary announcements so Game Over doesn't get auto-hidden
    let announceTimer = null;
    function pointerToCanvas(e){
      const rect = canvas.getBoundingClientRect();
      const x = (('touches' in e && e.touches[0]) ? e.touches[0].clientX : e.clientX) - rect.left;
      const y = (('touches' in e && e.touches[0]) ? e.touches[0].clientY : e.clientY) - rect.top;
      return { x: x * (canvas.width/rect.width), y: y * (canvas.height/rect.height) };
    }
    // remove pass aim handlers

    // On-screen pad and actions
    function bindPressButton(el, key){
      const down = ()=>{ keys.add(key); if(!state.snapped) startPlay(); };
      const up = ()=>{ keys.delete(key); };
      el.addEventListener('mousedown', (e)=>{ e.preventDefault(); down(); });
      el.addEventListener('mouseup', (e)=>{ e.preventDefault(); up(); });
      el.addEventListener('mouseleave', (e)=>{ e.preventDefault(); up(); });
      el.addEventListener('touchstart', (e)=>{ e.preventDefault(); down(); });
      el.addEventListener('touchend', (e)=>{ e.preventDefault(); up(); });
      el.addEventListener('touchcancel', (e)=>{ e.preventDefault(); up(); });
    }
    document.querySelectorAll('#pad .padbtn').forEach(btn=>{
      // Ensure any touch/click on a direction starts the play immediately
      const key = btn.getAttribute('data-key');
      bindPressButton(btn, key);
      btn.addEventListener('click', (e)=>{ e.preventDefault(); if(!state.snapped) startPlay(); });
      btn.addEventListener('touchstart', (e)=>{ e.preventDefault(); if(!state.snapped) startPlay(); }, {passive:false});
    });
    // dash button (mobile)
    try { const dashBtn = document.getElementById('dashBtn'); if(dashBtn){ dashBtn.addEventListener('click', (e)=>{ e.preventDefault(); tryDash(); }); } } catch(_){ }
    // boost button (mobile + desktop): 200% speed for 0.5s
    // Removed on-screen boost button; use keyboard B or tryBoost via other UI if added later
    // passing removed

    // Panic button handler
    const panicBtn = document.getElementById('panicBtn');
    panicBtn.addEventListener('click', (e) => {
      e.preventDefault();
      if(!state.snapped || state.gameOver || state.panicking) return;

      // Generate random backwards direction (always towards bottom of screen = own endzone)
      const backwardsAngle = Math.PI + (Math.random() - 0.5) * Math.PI; // 180° ± 90° = 90° to 270°
      state.panicVec.vx = Math.cos(backwardsAngle);
      state.panicVec.vy = Math.sin(backwardsAngle);

      // Ensure it's always moving backwards (positive Y = towards bottom)
      if(state.panicVec.vy < 0.3) state.panicVec.vy = 0.3 + Math.random() * 0.7;

      state.panicking = true;
      state.panicMs = 800; // 0.8 seconds of panic
      state.panicBtnVisible = false;
      panicBtn.style.display = 'none';

      // Play panic sound based on field position
      playPanicSound();
    });

    function getMoveVector(){
      let vx=0, vy=0;
      if(keys.has('ArrowLeft')||keys.has('a')||keys.has('A')) vx -= 1;
      if(keys.has('ArrowRight')||keys.has('d')||keys.has('D')) vx += 1;
      if(keys.has('ArrowUp')||keys.has('w')||keys.has('W')) vy -= 1;
      if(keys.has('ArrowDown')||keys.has('s')||keys.has('S')) vy += 1;
      const len = Math.hypot(vx,vy)||1; vx/=len; vy/=len;
      return {vx,vy, sprint: keys.has('Shift')};
    }

    // passing removed

    // passing removed

    // kick removed

    function predictTarget(){
      // Aim at active receiver with slight lead towards mouse direction
      const r = state.receivers[state.activeReceiver];
      const mx = state.mouse.x, my = state.mouse.y;
      const towardMouse = {x: r.x + (mx - r.x)*0.15, y: r.y + (my - r.y)*0.15};
      // Lead if receiver moving
      return {x: towardMouse.x + r.vx*PASS_LEAD, y: towardMouse.y + r.vy*PASS_LEAD};
    }

    // AI: defenders read intent (run vs pass) and react
    function updateDefenders(){
      const qb = state.qb;
      const hasAir = state.hasBall==='air';
      const intentRun = state.hasBall!=='air' && Math.hypot(qb.vx,qb.vy)>0.8; // moving with ball
      const intentPass = state.hasBall==='qb' && !intentRun;
      // Increase speed more gradually: +5% per level
      const levelSpeedMult = 1 + 0.05 * Math.max(0, (state.level||1) - 1);

      // Apple acceleration boost: at most one apple gains +50% acceleration for 0.5s
      try {
        const apples = state.defenders.filter(d=>d.type==='apple');
        const hasAccelActive = apples.some(d=> (d.accelBoost||0) > 0);
        if(!hasAccelActive && apples.length>0){
          // ~0.8% chance per frame (~1.25s average)
          if(Math.random() < 16/2000){
            const pick = apples[(Math.random()*apples.length)|0];
            pick.accelBoost = 500; // ms (approx)
          }
        }
      } catch(_){}

      for(const d of state.defenders){
        if(d.reactDelay==null){ d.reactDelay = Math.random()*(DEF_REACT_MAX_MS-DEF_REACT_MIN_MS)+DEF_REACT_MIN_MS; d.reactAccum=0; }
        d.reactAccum += 16; // approx per frame
        d.leafCooldown = (d.leafCooldown||0) - 16;
        let reactNow = d.reactAccum >= d.reactDelay;
        // Pursue current ball carrier directly with slight predictive lead
        const cx = qb.x; const cy = qb.y;
        let tx = cx, ty = cy;
        if(reactNow){
          tx = cx + state.qb.vx * 14; // small lead
          ty = cy + state.qb.vy * 14;
        }
        // Add tiny lateral offset so they can surround from any side
        tx += (d.offsetX || 0); ty += (d.offsetY || 0);
        if(d.offsetX==null){ d.offsetX = (Math.random()*2-1)*20; d.offsetY = (Math.random()*2-1)*20; }

        const dirx = clamp(tx - d.x, -1, 1);
        const diry = clamp(ty - d.y, -1, 1);
        const len = Math.hypot(dirx,diry)||1; const ux = dirx/len, uy = diry/len;
        // Apple burst logic: every ~1s, apples can sprint at 3x for 1s
        if(d.type==='apple'){
          d.burstCooldown = (d.burstCooldown||0) - 16; d.burst = (d.burst||0) - 16;
          d.accelBoost = (d.accelBoost||0) - 16; // separate acceleration boost timer
          if(d.burst<=0 && d.burstCooldown<=0){
            if(Math.random() < 16/1000){ d.burst = 1000; d.burstCooldown = 1000; }
          }
        }
        let burstMult = (d.type==='apple' && d.burst>0) ? 3.0 : 1.0;
        let speed = (d.role==='rusher' ? DEF_SPEED*1.0 : DEF_SPEED*0.95) * (d.speedMult || 1.0) * burstMult * levelSpeedMult;
        const carrierX = (state.hasBall==='qb') ? qb.x : (typeof state.hasBall==='number' ? state.receivers[state.hasBall].x : qb.x);
        const carrierY = (state.hasBall==='qb') ? qb.y : (typeof state.hasBall==='number' ? state.receivers[state.hasBall].y : qb.y);
        const distToCarrier = Math.hypot(d.x - carrierX, d.y - carrierY);
        if(!hasAir && distToCarrier < 160) speed *= 1.05;
        // Smooth defender acceleration (+50% accel for boosted apple)
        const accelMult = (d.type==='apple' && (d.accelBoost||0) > 0) ? 1.5 : 1.0;
        d.vx += (ux*speed - d.vx) * DEF_ACCEL * accelMult;
        d.vy += (uy*speed - d.vy) * DEF_ACCEL * accelMult;
        d.x += d.vx; d.y += d.vy;
        if(reactNow){ d.reactAccum = 0; d.reactDelay = Math.random()*(DEF_REACT_MAX_MS-DEF_REACT_MIN_MS)+DEF_REACT_MIN_MS; }
        // Only some fruits are shooters at the start of a down; lazily assign per-play flag
        // Scale shooting probability based on level (starts low, increases slowly)
        if(d.canShoot == null){
          const baseShootChance = 0.25; // Start at 25% in early levels
          const levelBonus = Math.min(0.4, (state.level - 1) * 0.06); // +6% per level, max +40%
          const shootChance = Math.min(0.65, baseShootChance + levelBonus); // Cap at 65%
          d.canShoot = Math.random() < shootChance;
        }

        // Determine which fruit types can shoot based on level
        const canShootTypes = [];
        if(d.type==='apple' || d.type==='orange' || d.type==='pear'){
          canShootTypes.push(d.type);
        }
        // Add more types as levels increase (more gradual progression)
        if(state.level >= 5 && d.type==='banana'){
          canShootTypes.push('banana'); // Bananas start shooting at level 5
        }
        if(state.level >= 8 && d.type==='apple'){
          canShootTypes.push('apple'); // Extra apples at level 8+
        }

        // Shoot leaf toward carrier for fruits that can shoot
        if(state.snapped && d.canShoot && d.leafCooldown<=0 && canShootTypes.length > 0){
          const carrier = (state.hasBall==='qb') ? state.qb : (typeof state.hasBall==='number' ? state.receivers[state.hasBall] : state.qb);
          // Smart aim: bias aim slightly toward player's current velocity when chasing from behind
          let aimX = carrier.x, aimY = carrier.y;
          const toPlayerX = carrier.x - d.x, toPlayerY = carrier.y - d.y;
          const facing = (toPlayerX*(state.qb.vx||0) + toPlayerY*(state.qb.vy||0));
          if(facing > 0){ // roughly behind the player
            aimX += state.qb.vx * 28; aimY += state.qb.vy * 28;
          }
          const dx = aimX - d.x, dy = aimY - d.y; const dl = Math.hypot(dx,dy)||1;
          if(dl < 560){
            const ux = (dx/dl), uy = (dy/dl);
            // spawn slightly ahead of the shooter to avoid instant self-collision
            const startOffset = DEFENDER_R + 4;
            const proj = { x:d.x + ux*startOffset, y:d.y + uy*startOffset, vx:ux*LEAF_SPEED, vy:uy*LEAF_SPEED, ttl: 2500, shooter:d, age:0 };
            // 35% chance to add a swirling component perpendicular to direction
            if(Math.random() < 0.35){
              const perpX = -uy, perpY = ux; // unit perpendicular
              proj.swirl = {
                px: perpX,
                py: perpY,
                t: 0,
                rate: 0.008 + Math.random()*0.012, // radians per ms factor
                mag: 0.8 + Math.random()*1.2 // px/frame amplitude
              };
            }
            state.projectiles.push(proj);
            // Increase fire rate gradually as levels progress
            const baseCooldown = 900 + Math.random()*1200; // 900-2100ms base
            const levelReduction = Math.min(0.4, (state.level - 1) * 0.05); // -5% per level, max -40%
            const rateMult = 1 + levelReduction;
            d.leafCooldown = baseCooldown / rateMult;
          }
        }
      }
      // After moving defenders, resolve blocking so fruits impede each other
      resolveDefenderBlocking();
    }

    // Receivers simple routes
    function updateReceivers(){
      const snapPush = state.snapped ? 1 : 0;
      for(const [i,r] of state.receivers.entries()){
        if(!state.snapped){ r.vx=0; r.vy=0; continue; }
        switch(r.route){
          case 'slant': r.vx = 0.9*snapPush; r.vy = -1.2*snapPush; break;
          case 'go': r.vx = 0; r.vy = -1.4*snapPush; break;
          case 'out': r.vx = i%2? -1.0*snapPush : 1.0*snapPush; r.vy = -0.9*snapPush; break;
        }
        // Smooth receiver movement a bit
        r.x = clamp(r.x + r.vx*0.9, 40, W-40);
        r.y = clamp(r.y + r.vy*0.9, 30, H-30);
      }
    }

    function updateQB(){
      const m = getMoveVector();
      // Priority: panic > dash > normal movement
      let useVec = m;
      let speed = BASE_SPEED * PLAYER_SPEED_BONUS * (m.sprint ? SPRINT_MULT : 1);
      if(state.boostMs>0) speed *= 2.0; // 200% speed during boost
      if(state.panicking){
        useVec = state.panicVec; // predetermined panic vector
        speed = BASE_SPEED * 5; // 5x speed during panic
      } else if(state.dashing){
        useVec = state.dashVec; // predetermined random vector with positive Y
        speed = BASE_SPEED * 10; // x10 pace
      }
      if(state.hasBall==='qb') speed *= CARRIER_MULT; // carrier bonus
      state.sprint = m.sprint;
      // Smooth acceleration
      const prevY_qb = state.qb.y;
      const accelNow = (state.boostMs>0) ? ACCEL * 2.5 : ACCEL; // react faster during boost
      state.qb.vx += (useVec.vx * speed - state.qb.vx) * accelNow;
      state.qb.vy += (useVec.vy * speed - state.qb.vy) * accelNow;
      // Small immediate impulse so boost is felt instantly
      if(state.boostMs>0 && Math.hypot(m.vx,m.vy)>0.1){
        state.qb.vx += useVec.vx * BASE_SPEED * 0.4;
        state.qb.vy += useVec.vy * BASE_SPEED * 0.4;
      }
      if(Math.hypot(m.vx, m.vy) > 0.01){ state.lastMoveDir = { x: m.vx, y: m.vy }; }
      state.qb.x = clamp(state.qb.x + state.qb.vx, 40, W-40);
      state.qb.y = clamp(state.qb.y + state.qb.vy, 30, H-30);
      // During dash, never gain yards (do not move upward on the screen)
      if(state.dashing && state.qb.y < prevY_qb){ state.qb.y = prevY_qb; }
      // Stop dash when reaching screen limits
      if(state.dashing){
        if(state.qb.y >= H-30 || state.qb.x <= 40 || state.qb.x >= W-40){ state.dashing=false; state.dashMs=0; }
      }
      if(state.hasBall==='qb') {
        placeBallOnQB();
        // Update ball position in yards for music intensity
        state.ballOnYard = Math.max(0, yToYard(state.qb.y));
      }
    }

    function updateBall(){
      if(state.hasBall==='air'){
        state.ballPos.x += state.ballVel.x;
        state.ballPos.y += state.ballVel.y;
        let caughtBy = null; let bestDist = 9999;
        for(const [i,r] of state.receivers.entries()){
          const d = Math.hypot(r.x - state.ballPos.x, r.y - state.ballPos.y);
          if(d < 18 && d < bestDist){ bestDist = d; caughtBy = i; }
        }
        if(caughtBy!==null){
          state.hasBall = caughtBy; // receiver index
          state.ballVel.x = state.ballVel.y = 0;
          // Announce yards gained and yards to go immediately on catch
          const spotYardsExact = (H - 30 - state.ballPos.y) / PX_PER_YARD;
          const gainedSoFar = Math.max(0, spotYardsExact - state.lineOfScrimmageYard);
          const toGoNow = Math.max(0, state.distance - gainedSoFar);
          showCenterMessage(`Caught! +${yardsText(gainedSoFar)} yards — ${yardsText(toGoNow)} yards to go`);
        }
        if(state.ballPos.x < 40 || state.ballPos.x > W-40 || state.ballPos.y < 20){
          whistleDead('incomplete');
        }
      } else if(typeof state.hasBall==='number'){
        const r = state.receivers[state.hasBall];
        // Allow control of the receiver who caught the ball (carrier boost)
        const m = getMoveVector();
        let useVec = m;
        let speed = BASE_SPEED * PLAYER_SPEED_BONUS * (m.sprint ? SPRINT_MULT : 1);
        // Boost only applies to QB, not receivers
        if(state.dashing){ useVec = state.dashVec; speed = BASE_SPEED * 10; }
        const prevY_r = r.y;
        speed *= CARRIER_MULT;
        r.vx = useVec.vx * speed; r.vy = useVec.vy * speed;
        r.x = clamp(r.x + r.vx, 40, W-40);
        r.y = clamp(r.y + r.vy, 30, H-30);
        if(state.dashing && r.y < prevY_r){ r.y = prevY_r; }
        if(state.dashing){
          if(r.y >= H-30 || r.x <= 40 || r.x >= W-40){ state.dashing=false; state.dashMs=0; }
        }
        state.ballPos.x = r.x; state.ballPos.y = r.y-6;
        // Update ball position in yards for music intensity when receiver has ball
        state.ballOnYard = Math.max(0, yToYard(r.y));
      }
    }

    function whistleDead(reason){
      // End of play: spot ball and advance down; never reset to 1st down
      const spotYardsInt = yToYard(state.ballPos.y);
      const spotYardsExact = (H - 30 - state.ballPos.y) / PX_PER_YARD; // exact yards as float
      if(reason==='touchdown' || spotYardsInt>=100){
        state.scored = true;
        state.playActive = false; state.snapped = false; state.gameOver = true;
        stopBgMusic(); // Stop background music on touchdown
        playCrowdRoar();
        const downsUsed = state.down;
        const nextLevel = Math.min(999, (state.level||1) + 1);
        const msg = `Touchdown! Level ${state.level} complete in ${downsUsed} down${downsUsed===1?'':'s'}!` + (window.innerWidth<=820? '<br/>' : '\n') + `Proceed to level ${nextLevel}?`;
        state.pendingNextLevel = nextLevel;
        showGameOver(msg);
        return;
      }
      // Clear all leaves at the end of a play
      try{ state.projectiles = []; }catch(_){ state.projectiles = []; }
      stopBgMusic(); // Stop background music on any play end
      let gained = spotYardsExact - state.lineOfScrimmageYard;
      if(reason==='incomplete') gained = 0; // incomplete pass: no yardage
      // Reduce yards to go but never reset to a new first down
      state.distance = Math.max(0, state.distance - Math.max(0, gained));
      state.ballOnYard = Math.max(1, spotYardsExact);
      state.down += 1;
      if(state.down>4){
        state.playActive = false; state.snapped = false; state.gameOver = true;
        // Reduce level by 1 (not below 1) and prompt to retry that level
        const previous = Math.max(1, (state.level||1) - 1);
        state.level = previous;
        state.pendingNextLevel = previous;
        const retryLabel = `Try level ${previous} again?`;
        showGameOver(`No score in 4 tries. Game Over`);
        // patch button label after render
        setTimeout(()=>{
          try{
            const yesBtn = document.getElementById('playAgainYes');
            if(yesBtn) yesBtn.textContent = retryLabel;
          }catch(_){ }
        }, 0);
      } else {
        announceDown();
        resetPlay();
      }
    }

    function checkTackles(){
      let carrier = null; let cx=0, cy=0;
      if(state.hasBall==='qb'){ carrier = state.qb; cx = carrier.x; cy = carrier.y; }
      else if(typeof state.hasBall==='number'){ const r = state.receivers[state.hasBall]; carrier = r; cx = r.x; cy = r.y; }
      else return;
      // Tackle only on visible overlap (strict contact)
      if(state.dashMs>0){ if(cy<=30){ whistleDead('touchdown'); } return; }
      for(const d of state.defenders){
        if(distance(d,{x:cx,y:cy}) <= PLAYER_R + DEFENDER_R - CONTACT_PAD){
          stopBgMusic(); // Stop music immediately on tackle
          whistleDead('tackle'); return;
        }
      }
      if(cy <= 30){ whistleDead('touchdown'); }
    }

    function distance(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
    function clamp(v,lo,hi){ return Math.max(lo, Math.min(hi, v)); }

    // Defenders physically block each other so a slower fruit can shield the runner
    function defenderMass(d){
      const speed = Math.max(0.5, d.speedMult || 1);
      const burstFactor = (d.type==='apple' && d.burst>0) ? 3.0 : 1.0;
      // Slower fruits have greater mass; bursty fast apples are lighter
      return 1 / (speed * burstFactor);
    }
    function resolveDefenderBlocking(){
      const defenders = state.defenders;
      if(!defenders || defenders.length < 2) return;
      const minDist = DEFENDER_R*2 - 2; // allow slight visual overlap
      for(let i=0; i<defenders.length; i++){
        for(let j=i+1; j<defenders.length; j++){
          const a = defenders[i], b = defenders[j];
          const dx = b.x - a.x, dy = b.y - a.y;
          const dist = Math.hypot(dx,dy) || 0.0001;
          if(dist < minDist){
            const nx = dx / dist, ny = dy / dist;
            const overlap = (minDist - dist);
            const ma = defenderMass(a), mb = defenderMass(b);
            const total = ma + mb;
            const pushA = overlap * (mb/total);
            const pushB = overlap * (ma/total);
            a.x = clamp(a.x - nx * pushA, 40, W-40);
            a.y = clamp(a.y - ny * pushA, 30, H-30);
            b.x = clamp(b.x + nx * pushB, 40, W-40);
            b.y = clamp(b.y + ny * pushB, 30, H-30);
            // Damp movement when colliding to simulate getting stuck behind a blocker
            a.vx *= 0.75; a.vy *= 0.75;
            b.vx *= 0.75; b.vy *= 0.75;
          }
        }
      }
    }

    // Render
    function drawField(){
      ctx.save();
      ctx.globalAlpha = 1;
      ctx.shadowColor = 'transparent';
      ctx.filter = 'none';
      ctx.clearRect(0,0,W,H);
      // Turf stripes via CSS background already present; draw yard lines and numbers
      ctx.strokeStyle = 'rgba(255,255,255,0.8)';
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.lineWidth = 2;
      for(let y=0;y<=FIELD_LEN_YARDS;y+=YARDS_PER_LINE){
        const py = yardToY(y);
        ctx.beginPath(); ctx.moveTo(40, py); ctx.lineTo(W-40, py); ctx.stroke();
        if(y>0 && y<100){
          ctx.font = '12px Arial Black'; ctx.textAlign='center'; ctx.textBaseline='middle';
          ctx.fillText(String(y), 30, py);
          ctx.fillText(String(100-y), W-30, py);
        }
      }
      // Hash marks
      ctx.lineWidth = 1;
      for(let y=5; y<100; y+=1){
        const py = yardToY(y);
        ctx.beginPath(); ctx.moveTo(LEFT_HASH-10, py); ctx.lineTo(LEFT_HASH, py); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(RIGHT_HASH, py); ctx.lineTo(RIGHT_HASH+10, py); ctx.stroke();
      }
      // End zones in red
      ctx.fillStyle = 'rgba(239,68,68,0.30)';
      ctx.fillRect(40, H-30, W-80, 30);
      ctx.fillStyle = 'rgba(220,38,38,0.30)';
      ctx.fillRect(40, 0, W-80, 30);
      ctx.restore();
    }

    function drawPlayers(){
      ctx.save();
      ctx.globalAlpha = 1;
      ctx.shadowColor = 'transparent';
      ctx.filter = 'none';
      // Attacking player as cute emoji runner holding a football
      drawRunner(state.qb.x, state.qb.y);
      // Defenders as fruit icons (larger and crisper)
      for(const d of state.defenders){
        const label = d.icon || '🛡️';
        ctx.font = FRUIT_FONT_SIZE + 'px "Segoe UI Emoji", "Apple Color Emoji", Noto Color Emoji, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(label, d.x, d.y);
      }
      // Ball ellipse suppressed (shown via emoji on runner)
      ctx.restore();
    }

    function drawProjectiles(){
      if(!state.projectiles || state.projectiles.length===0) return;
      ctx.save();
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.font = '34px "Segoe UI Emoji", "Apple Color Emoji", Noto Color Emoji, sans-serif';
      for(const p of state.projectiles){ ctx.fillText('🍃', p.x, p.y); }
      ctx.restore();
    }

    function drawCircle(x,y,r,color){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fillStyle=color; ctx.fill(); }
    function drawRing(x,y,r,color){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.strokeStyle=color; ctx.lineWidth=2; ctx.stroke(); }
    function drawEllipse(x,y,rx,ry){ ctx.save(); ctx.translate(x,y); ctx.scale(rx/ry,1); ctx.beginPath(); ctx.arc(0,0,ry,0,Math.PI*2); ctx.restore(); ctx.fill(); }
    function drawRunner(x,y){
      ctx.save();
      ctx.globalAlpha = 1;
      ctx.shadowColor = 'transparent';
      ctx.filter = 'none';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      // Cute person emoji
      ctx.font = '64px "Segoe UI Emoji", "Apple Color Emoji", Noto Color Emoji, sans-serif';
      ctx.fillText('🧒', x, y - 6);
      // Football emoji tucked to the right
      ctx.font = '48px "Segoe UI Emoji", "Apple Color Emoji", Noto Color Emoji, sans-serif';
      ctx.fillText('🏈', x + PLAYER_R, y - 4);
      ctx.restore();
    }

    function tick(dt){
      if(state.gameOver){
        return;
      }
      if(state.playActive){
        state.clockMs = Math.max(0, state.clockMs - dt);
      }
      // ability timers
      state.dashMs = Math.max(0, state.dashMs - dt);
      state.boostMs = Math.max(0, (state.boostMs||0) - dt);
      state.boostCooldownMs = Math.max(0, (state.boostCooldownMs||0) - dt);
      state.panicMs = Math.max(0, state.panicMs - dt);
      if(state.dashing && state.dashMs<=0){ state.dashing=false; }
      if(state.panicking && state.panicMs<=0){ state.panicking=false; }
      state.levelIntroMs = Math.max(0, (state.levelIntroMs||0) - dt);

      // Show panic button when defenders are closing in
      if(state.snapped && state.playActive && !state.gameOver && !state.panicking && !state.panicBtnVisible){
        state.lastPanicCheck += dt;
        if(state.lastPanicCheck > 500){ // Check every 0.5 seconds
          state.lastPanicCheck = 0;

          // Check if any defender is within danger distance
          let closestDefenderDist = Infinity;
          for(const d of state.defenders){
            const dist = Math.hypot(d.x - state.qb.x, d.y - state.qb.y);
            if(dist < closestDefenderDist) closestDefenderDist = dist;
          }

          // Show panic button if defender is within 120 pixels (danger zone)
          if(closestDefenderDist <= 120){
            state.panicBtnVisible = true;
            panicBtn.style.display = 'block';
            // Hide after 2 seconds if not clicked (shorter time when in danger)
            setTimeout(() => {
              if(state.panicBtnVisible && !state.panicking){
                state.panicBtnVisible = false;
                panicBtn.style.display = 'none';
              }
            }, 2000);
          }
        }
      }

      if(state.snapped){
        // Enforce max play duration (20s) to always end a down
        if(state.playStartMs && performance.now() - state.playStartMs > 20000){ whistleDead('tackle'); return; }
        updateQB();
        updateReceivers();
        updateDefenders();
        updateBall();
        // Update background music parameters based on current position
        updateBgMusic();
        // update projectiles
        if(state.projectiles && state.projectiles.length){
          const keep = [];
          const carrier = (state.hasBall==='qb') ? state.qb : (typeof state.hasBall==='number' ? state.receivers[state.hasBall] : state.qb);
          for(const p of state.projectiles){
            p.age = (p.age||0) + dt;
            // swirling offset if present
            if(p.swirl){
              p.swirl.t += dt;
              const s = Math.sin(p.swirl.t * p.swirl.rate) * p.swirl.mag;
              p.x += p.vx + p.swirl.px * s;
              p.y += p.vy + p.swirl.py * s;
            } else {
              p.x += p.vx; p.y += p.vy;
            }
            p.ttl -= dt;
            if(p.x<30 || p.x>W-30 || p.y<10 || p.y>H-10 || p.ttl<=0) continue;
            if(distance({x:p.x,y:p.y}, carrier) <= PLAYER_R){ whistleDead('tackle'); continue; }
            // collide with defenders and bounce
            let bounced = false;
            for(const d of state.defenders){
              const dist = distance({x:p.x,y:p.y}, d);
              // ignore the shooter for a brief grace period to ensure effectiveness
              if(d === p.shooter && p.age < 160) { continue; }
              if(dist <= DEFENDER_R){
                // simple elastic reflection off normal
                const nx = (p.x - d.x) / (dist||0.0001);
                const ny = (p.y - d.y) / (dist||0.0001);
                const dot = p.vx*nx + p.vy*ny;
                p.vx = p.vx - 2*dot*nx;
                p.vy = p.vy - 2*dot*ny;
                // dampen slightly
                p.vx *= 0.9; p.vy *= 0.9;
                bounced = true;
                break;
              }
            }
            keep.push(p);
          }
          state.projectiles = keep;
        }
        checkTackles();
      }
    }

    // Main loop
    let last = performance.now();
    function loop(now){
      const dt = Math.min(50, now - last); last = now;
      tick(dt);
      drawField();
      drawPlayers();
      drawProjectiles();
      // small HUD showing ability cooldown
      try{ drawAbilityHud(); }catch(_){ }
      requestAnimationFrame(loop);
    }

    // Init: scale canvas for sharpness without shrinking CSS sizes
    let FRUIT_FONT_SIZE = 58;
    function resizeCanvas(){
      const cssW = canvas.clientWidth;
      const cssH = canvas.clientHeight;
      canvas.width = Math.floor(cssW * DPR);
      canvas.height = Math.floor(cssH * DPR);
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      W = cssW;
      H = cssH;
      PX_PER_YARD = (H - 60) / FIELD_LEN_YARDS;
      LEFT_HASH = 80; RIGHT_HASH = W - 80;
      // Mobile scaling: reduce fruit size 30% and increase carrier speed to 3x
      const isMobile = cssW <= 820;
      FRUIT_FONT_SIZE = isMobile ? Math.round(58 * 0.7) : 58;
      DEFENDER_R = isMobile ? Math.round(22 * 0.7) : 22;
      CARRIER_MULT = 3.0; // 3x on all devices
      ACCEL = isMobile ? 0.18 : 0.12; // slightly quicker acceleration on mobile
      // Ensure the top red end zone remains visible on mobile by reserving extra space
      if(isMobile){
        PX_PER_YARD = (H - 80) / FIELD_LEN_YARDS; // add 20px margin at top
      }
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    resetPlay();
    requestAnimationFrame(loop);

    // Whistle and announcements
    function playWhistle(){
      try{
        const ac = new (window.AudioContext||window.webkitAudioContext)();
        const o = ac.createOscillator();
        const g = ac.createGain();
        o.type = 'sine';
        o.frequency.setValueAtTime(800, ac.currentTime);
        o.frequency.exponentialRampToValueAtTime(1600, ac.currentTime + 0.15);
        o.frequency.exponentialRampToValueAtTime(900, ac.currentTime + 0.35);
        g.gain.setValueAtTime(0.0001, ac.currentTime);
        g.gain.exponentialRampToValueAtTime(0.25, ac.currentTime + 0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, ac.currentTime + 0.45);
        o.connect(g).connect(ac.destination);
        o.start(); o.stop(ac.currentTime + 0.5);
      }catch(_){/* ignore */}
    }
    function announceDown(){
      const el = document.getElementById('announce');
      el.textContent = `${ordinal(state.down)} down - ${yardsText(state.distance)} yards to go`;
      // Position in the center of the screen with very large red text
      el.style.left = '50%';
      el.style.top = '50%';
      el.style.transform = 'translate(-50%, -50%)';
      el.style.display = 'block'; el.style.opacity = '1';
      // Gradient red text styling
      el.style.color = '#ff1a1a';
      el.style.background = 'linear-gradient(180deg, #ff4d4d, #b91c1c)';
      el.style.webkitBackgroundClip = 'text';
      el.style.backgroundClip = 'text';
      el.style.webkitTextFillColor = 'transparent';
      el.style.fontSize = (window.innerWidth<=820? '36px' : '72px');
      el.style.fontWeight = '900';
      el.style.borderColor = 'rgba(255,26,26,.85)';
      // Fade out and restore original top positioning for other messages
      if(announceTimer){ try{ clearTimeout(announceTimer); }catch{} announceTimer=null; }
      announceTimer = setTimeout(()=>{
        el.style.transition='opacity .6s'; el.style.opacity='0';
        announceTimer = setTimeout(()=>{
          el.style.display='none'; el.style.transition='';
          el.style.top = '18px';
          el.style.transform = 'translateX(-50%)';
          announceTimer = null;
        }, 700);
      }, 1800);
    }

    function showCenterMessage(msg){
      const el = document.getElementById('announce');
      el.textContent = msg;
      el.style.left = '50%';
      el.style.top = '50%';
      el.style.transform = 'translate(-50%, -50%)';
      el.style.display = 'block'; el.style.opacity = '1';
      // Gradient red text styling
      el.style.color = '#ff1a1a';
      el.style.background = 'linear-gradient(180deg, #ff4d4d, #b91c1c)';
      el.style.webkitBackgroundClip = 'text';
      el.style.backgroundClip = 'text';
      el.style.webkitTextFillColor = 'transparent';
      el.style.fontSize = (window.innerWidth<=820? '28px' : '56px');
      el.style.fontWeight = '900';
      el.style.borderColor = 'rgba(255,26,26,.85)';
      if(announceTimer){ try{ clearTimeout(announceTimer); }catch{} announceTimer=null; }
      announceTimer = setTimeout(()=>{
        el.style.transition='opacity .6s'; el.style.opacity='0';
        announceTimer = setTimeout(()=>{
          el.style.display='none'; el.style.transition='';
          el.style.top = '18px';
          el.style.transform = 'translateX(-50%)';
          announceTimer = null;
        }, 700);
      }, 1200);
    }

    function showLevelIntro(){
      const el = document.getElementById('announce');
      el.textContent = `Level ${state.level}`;
      el.style.left = '50%';
      el.style.top = '24%';
      el.style.transform = 'translate(-50%, -50%)';
      el.style.display = 'block'; el.style.opacity = '1';
      el.style.color = '#ef4444';
      el.style.background = 'linear-gradient(180deg, #fecaca, #ef4444)';
      el.style.webkitBackgroundClip = 'text';
      el.style.backgroundClip = 'text';
      el.style.webkitTextFillColor = 'transparent';
      el.style.fontSize = (window.innerWidth<=820? '28px' : '56px');
      el.style.fontWeight = '900';
      state.levelIntroMs = 1300;
      if(announceTimer){ try{ clearTimeout(announceTimer); }catch{} announceTimer=null; }
      announceTimer = setTimeout(()=>{
        el.style.transition='opacity .8s'; el.style.opacity='0';
        announceTimer = setTimeout(()=>{ el.style.display='none'; el.style.transition=''; announceTimer=null; }, 900);
      }, 1100);
    }

    function playCrowdRoar(){
      try{
        const ac = new (window.AudioContext||window.webkitAudioContext)();
        const len = 1.2;
        const bufferSize = ac.sampleRate * len;
        const buffer = ac.createBuffer(1, bufferSize, ac.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i=0;i<bufferSize;i++) { data[i] = (Math.random()*2-1) * (1 - i/bufferSize); }
        const noise = ac.createBufferSource(); noise.buffer = buffer;
        const filter = ac.createBiquadFilter(); filter.type='bandpass'; filter.frequency.value=600; filter.Q.value=0.7;
        const gain = ac.createGain(); gain.gain.setValueAtTime(0.0001, ac.currentTime); gain.gain.exponentialRampToValueAtTime(0.6, ac.currentTime+0.05); gain.gain.exponentialRampToValueAtTime(0.001, ac.currentTime+len);
        noise.connect(filter).connect(gain).connect(ac.destination);
        noise.start(); noise.stop(ac.currentTime + len);
      }catch(_){/* ignore */}
    }

    function playPanicSound(){
      try{
        const ac = new (window.AudioContext||window.webkitAudioContext)();
        const len = 0.8;

        // Calculate excitement based on yards to endzone (closer = more exciting)
        const yardsToEndzone = Math.max(0, 100 - state.ballOnYard);
        const excitement = Math.min(1, yardsToEndzone / 80); // 0 to 1 scale

        // Create layered panic sound
        const oscillators = [];

        // High-pitched panic tone (gets higher with excitement)
        const osc1 = ac.createOscillator();
        osc1.type = 'sawtooth';
        osc1.frequency.setValueAtTime(800 + excitement * 400, ac.currentTime);
        osc1.frequency.exponentialRampToValueAtTime(1200 + excitement * 600, ac.currentTime + len);
        oscillators.push(osc1);

        // Medium panic tone
        const osc2 = ac.createOscillator();
        osc2.type = 'square';
        osc2.frequency.setValueAtTime(400 + excitement * 200, ac.currentTime);
        osc2.frequency.exponentialRampToValueAtTime(600 + excitement * 300, ac.currentTime + len);
        oscillators.push(osc2);

        // Low rumble (more intense with excitement)
        const osc3 = ac.createOscillator();
        osc3.type = 'triangle';
        osc3.frequency.setValueAtTime(150 + excitement * 100, ac.currentTime);
        osc3.frequency.exponentialRampToValueAtTime(200 + excitement * 150, ac.currentTime + len);
        oscillators.push(osc3);

        // Connect oscillators with varying gains
        const masterGain = ac.createGain();
        masterGain.gain.setValueAtTime(0.0001, ac.currentTime);
        masterGain.gain.exponentialRampToValueAtTime(0.4 + excitement * 0.3, ac.currentTime + 0.05);
        masterGain.gain.exponentialRampToValueAtTime(0.001, ac.currentTime + len);

        oscillators.forEach((osc, i) => {
          const gain = ac.createGain();
          const gainValue = i === 0 ? 0.6 : i === 1 ? 0.4 : 0.3; // Different volumes for each layer
          gain.gain.setValueAtTime(gainValue, ac.currentTime);
          osc.connect(gain).connect(masterGain);
          osc.start();
          osc.stop(ac.currentTime + len);
        });

        masterGain.connect(ac.destination);
      }catch(_){/* ignore */}
    }

    function startBgMusic(){
      if(state.bgMusicPlaying) return;
      try{
        const ac = new (window.AudioContext||window.webkitAudioContext)();

        // Musical melody notes (C major scale)
        const melodyNotes = [
          261.63, // C4
          293.66, // D4
          329.63, // E4
          349.23, // F4
          392.00, // G4
          440.00, // A4
          493.88, // B4
          523.25, // C5
        ];

        // Bass line notes
        const bassNotes = [
          130.81, // C3
          146.83, // D3
          164.81, // E3
          174.61, // F3
        ];

        // Create melody oscillator
        const melodyOsc = ac.createOscillator();
        melodyOsc.type = 'sine';
        melodyOsc.frequency.setValueAtTime(melodyNotes[0], ac.currentTime);

        // Create bass oscillator
        const bassOsc = ac.createOscillator();
        bassOsc.type = 'triangle';
        bassOsc.frequency.setValueAtTime(bassNotes[0], ac.currentTime);

        // Create harmony oscillator
        const harmonyOsc = ac.createOscillator();
        harmonyOsc.type = 'sine';
        harmonyOsc.frequency.setValueAtTime(melodyNotes[0] * 1.25, ac.currentTime); // Perfect fifth

        // Create gains
        const melodyGain = ac.createGain();
        melodyGain.gain.setValueAtTime(0.25, ac.currentTime);

        const bassGain = ac.createGain();
        bassGain.gain.setValueAtTime(0.3, ac.currentTime);

        const harmonyGain = ac.createGain();
        harmonyGain.gain.setValueAtTime(0.15, ac.currentTime);

        const masterGain = ac.createGain();
        masterGain.gain.setValueAtTime(0.5, ac.currentTime);

        // Connect everything
        melodyOsc.connect(melodyGain).connect(masterGain);
        bassOsc.connect(bassGain).connect(masterGain);
        harmonyOsc.connect(harmonyGain).connect(masterGain);
        masterGain.connect(ac.destination);

        // Start oscillators
        melodyOsc.start();
        bassOsc.start();
        harmonyOsc.start();

        // Store musical data and references
        state.bgMusicSource = {
          melodyOsc, bassOsc, harmonyOsc,
          melodyGain, bassGain, harmonyGain, masterGain, ac,
          melodyNotes, bassNotes,
          melodyIndex: 0,
          bassIndex: 0,
          lastNoteTime: ac.currentTime,
          currentBeatDuration: 60/100 // Start with base BPM
        };
        state.bgMusicPlaying = true;

      }catch(_){/* ignore */}
    }

    function updateBgMusic(){
      if(!state.bgMusicPlaying || !state.bgMusicSource) return;

      try{
        const { melodyOsc, bassOsc, harmonyOsc, melodyGain, bassGain, harmonyGain, masterGain, ac,
                melodyNotes, bassNotes, melodyIndex, bassIndex, lastNoteTime, currentBeatDuration } = state.bgMusicSource;

        const currentTime = ac.currentTime;

        // Calculate intensity based on yards to endzone (closer = more intense)
        const yardsToEndzone = Math.max(0, 100 - state.ballOnYard);
        const intensity = Math.max(0, 1 - (yardsToEndzone / 80)); // 0 to 1 scale, higher when closer

        // Dynamic tempo based on intensity
        const baseBPM = 100;
        const maxBPM = 200;
        const bpm = baseBPM + intensity * (maxBPM - baseBPM);
        const newBeatDuration = 60 / bpm;

        // Update stored beat duration
        state.bgMusicSource.currentBeatDuration = newBeatDuration;

        // Melody sequence (8 notes that repeat)
        const melodySequence = [0, 2, 4, 5, 4, 2, 0, -1]; // C major progression
        const melodyLength = melodySequence.length;

        // Bass sequence (4 notes that repeat)
        const bassSequence = [0, 2, 0, 3]; // Simple bass line
        const bassLength = bassSequence.length;

        // Update music based on current field position
        const currentMelodyIndex = Math.floor(currentTime / currentBeatDuration) % melodyLength;
        const currentBassIndex = Math.floor(currentTime / (currentBeatDuration * 2)) % bassLength;

        // Update melody
        const melodyNoteIndex = melodySequence[currentMelodyIndex];
        const actualNoteIndex = Math.max(0, Math.min(melodyNotes.length - 1, melodyNoteIndex + Math.floor(intensity * 3)));
        const melodyFreq = melodyNotes[actualNoteIndex];

        melodyOsc.frequency.setValueAtTime(melodyFreq, currentTime);
        harmonyOsc.frequency.setValueAtTime(melodyFreq * 1.25, currentTime); // Perfect fifth harmony

        // Update bass (half as often as melody)
        const bassNoteIndex = bassSequence[currentBassIndex];
        const actualBassIndex = Math.max(0, Math.min(bassNotes.length - 1, bassNoteIndex));
        const bassFreq = bassNotes[actualBassIndex];
        bassOsc.frequency.setValueAtTime(bassFreq, currentTime);

        // Store current indices for reference
        state.bgMusicSource.melodyIndex = currentMelodyIndex;
        state.bgMusicSource.bassIndex = currentBassIndex;

        // Dynamic volume adjustments
        const melodyVolume = 0.25 + intensity * 0.1;
        const bassVolume = 0.3 + intensity * 0.1;
        const harmonyVolume = 0.15 + intensity * 0.1;

        melodyGain.gain.setValueAtTime(melodyVolume, currentTime);
        bassGain.gain.setValueAtTime(bassVolume, currentTime);
        harmonyGain.gain.setValueAtTime(harmonyVolume, currentTime);

        // Overall volume increases with intensity
        masterGain.gain.setValueAtTime(0.5 + intensity * 0.2, currentTime);

      }catch(_){/* ignore */}
    }

    function stopBgMusic(){
      if(!state.bgMusicPlaying || !state.bgMusicSource) return;

      try{
        const { bassOsc, melodyOsc, accentOsc } = state.bgMusicSource;

        // Fade out
        const fadeTime = 0.5;
        const currentTime = state.bgMusicSource.ac.currentTime;
        state.bgMusicSource.masterGain.gain.exponentialRampToValueAtTime(0.001, currentTime + fadeTime);

        // Stop oscillators after fade
        setTimeout(() => {
          try{
            bassOsc.stop();
            melodyOsc.stop();
            accentOsc.stop();
          }catch(_){/* ignore */}
        }, fadeTime * 1000);

        state.bgMusicPlaying = false;
        state.bgMusicSource = null;

      }catch(_){/* ignore */}
    }

    function showGameOver(msg){
      const el = document.getElementById('announce');
      // Cancel any pending hide timers so the final message persists
      if(announceTimer){ try{ clearTimeout(announceTimer); }catch{} announceTimer=null; }
      // Reset any gradient text styles so buttons render correctly
      el.style.background = '';
      el.style.webkitBackgroundClip = '';
      el.style.backgroundClip = '';
      el.style.webkitTextFillColor = '';
      el.style.color = '#e2e8f0';
      // Render gradient only on the message span, not on the container
      // Hide control dock while in game over to let the player choose
      const dock = document.getElementById('dock'); if(dock) dock.style.display='none';
      const proceedLabel = (state.pendingNextLevel ? `Proceed to level ${state.pendingNextLevel}` : 'Play again');
      el.innerHTML = `<span style="display:block;background:linear-gradient(180deg,#ff4d4d,#b91c1c);-webkit-background-clip:text;background-clip:text;-webkit-text-fill-color:transparent;font-weight:900;">${msg}</span><div style="margin-top:14px;display:flex;gap:16px;justify-content:center"><button id=\"playAgainYes\" class=\"actbtn\" aria-label=\"Play again\" style=\"transform:scale(1.08);padding:10px 28px;-webkit-text-fill-color:#e2e8f0;color:#e2e8f0;\">Play again</button><button id=\"playAgainNo\" class=\"actbtn\" aria-label=\"Back to menu\" style=\"transform:scale(1.08);padding:10px 28px;-webkit-text-fill-color:#e2e8f0;color:#e2e8f0;\">Nah I'm good</button></div>`;
      el.style.display = 'block';
      el.style.opacity = '1';
      el.style.transition = '';
      const yesBtn = document.getElementById('playAgainYes');
      const noBtn = document.getElementById('playAgainNo');
      if (yesBtn) {
        yesBtn.addEventListener('click', function(){
          state.gameOver = false;
          // Reset full game state for a new run
          state.down = 1;
          state.distance = 75;
          state.ballOnYard = 25;
          state.clockMs = 45_000;
          state.hasBall = 'qb';
          resetPlay(25);
          el.style.display = 'none';
          // Restore the control dock after restarting
          if(dock) dock.style.display='flex';
        });
      }
      if (noBtn) {
        noBtn.addEventListener('click', function(){
          window.location.href = 'games.html';
        });
      }
    }
    function drawAbilityHud(){
      const x=W-130, y=10, w=110, h=8;
      ctx.save();
      // Sliders removed per request
      ctx.restore();
    }
    function tryDash(){
      if(!state.snapped){ startPlay(); }
      if(state.dashMs>0||state.dashCooldownMs>0) return;
      // pick a diagonal retreat direction with positive Y and horizontal component
      const dir = (Math.random() < 0.5) ? -1 : 1; // left or right
      const vx = dir * 0.7;
      const vy = 0.7; // strong downward
      state.dashVec = { vx, vy };
      state.dashing = true;
      state.dashMs=360; state.dashCooldownMs=2200;
    }

    function tryBoost(){
      if(!state.snapped){ startPlay(); }
      if((state.boostMs||0)>0 || (state.boostCooldownMs||0)>0) return;
      // Only allow boost when QB has the ball
      if(state.hasBall!=='qb') return;
      const mv = getMoveVector();
      // If no live key vector (e.g., mouse click), use lastMoveDir
      const dirx = Math.abs(mv.vx)>0.1 || Math.abs(mv.vy)>0.1 ? mv.vx : (state.lastMoveDir.x||0);
      const diry = Math.abs(mv.vx)>0.1 || Math.abs(mv.vy)>0.1 ? mv.vy : (state.lastMoveDir.y||0);
      if(Math.hypot(dirx, diry) < 0.1) return; // must have some direction
      state.boostMs = 500; // 0.5s
      state.boostCooldownMs = 1200; // short cooldown
      // Immediate impulse in the intended direction to make it feel instantaneous
      state.qb.vx += dirx * BASE_SPEED * 0.6;
      state.qb.vy += diry * BASE_SPEED * 0.6;
      showCenterMessage('Boost!');
    }
  })();
  </script>
</body>
</html>



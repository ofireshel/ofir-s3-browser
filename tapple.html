<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover">
  <title>LexiOrbit</title>
  <style>
    :root { 
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
    }
    html, body { 
      height: 100dvh; margin: 0; 
      font-family: 'Segoe UI', Arial, sans-serif; 
      background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%); 
      color: #e2e8f0; overflow: hidden; 
    }
    #app { 
      position: fixed; inset: 0; 
      display: grid; grid-template-rows: auto 1fr auto; 
    }
    header { 
      display:flex; align-items:center; gap:12px; padding:calc(8px + var(--safe-top)) 16px 12px 16px; 
      background: rgba(14,23,42,0.95); backdrop-filter: blur(8px); 
      border-bottom:1px solid #334155; box-shadow: 0 2px 8px rgba(0,0,0,0.3); 
    }
    header h1 { 
      font-size:20px; margin:0; font-weight:700; 
      background: linear-gradient(45deg, #60a5fa, #a78bfa); 
      background-clip: text; -webkit-background-clip: text; 
      -webkit-text-fill-color: transparent; 
    }
    header a { 
      color:#93c5fd; text-decoration:none; font-size:14px; 
      padding:6px 12px; border-radius:6px; transition: all 0.2s; 
    }
    header a:hover { background: rgba(147,197,253,0.1); }
    #hud { 
      display:flex; gap:16px; align-items:center; padding:12px 16px calc(10px + var(--safe-bottom)) 16px; 
      background: rgba(14,23,42,0.95); backdrop-filter: blur(8px); 
      border-top:1px solid #334155; box-shadow: 0 -2px 8px rgba(0,0,0,0.3); 
      position: relative;
    }
    #category { font-weight:800; font-size:44px; color:#fbbf24; letter-spacing:0.2px; }
    #timeBlock { position:absolute; left:50%; transform:translateX(-50%); display:flex; align-items:center; gap:10px; }
    #timeLabel { color:#94a3b8; font-weight:800; font-size:28px; }
    #timer { 
      font-variant-numeric: tabular-nums; font-weight:900; 
      color:#ef4444; font-size:52px; text-shadow: 0 0 12px currentColor; 
    }
    /* Word input removed */
    button { 
      padding:10px 16px; border-radius:8px; border:2px solid #475569; 
      background: linear-gradient(135deg, #1e293b, #334155); 
      color:#e2e8f0; cursor:pointer; font-weight:600; 
      transition: all 0.2s; 
    }
    button:hover { 
      background: linear-gradient(135deg, #334155, #475569); 
      border-color:#60a5fa; transform: translateY(-1px); 
    }
    #gameCanvas { 
      position: absolute; top: 0; left: 0; 
      width: 100%; height: 100%; 
      cursor: pointer; 
    }
    #stage { height: 100%; overflow: hidden; position: relative; }
    .chip { 
      padding:6px 12px; border-radius:999px; border:1px solid #475569; 
      background: rgba(30,41,59,0.8); font-size:13px; font-weight:500; 
    }
    /* Removed floating log ribbon on mobile/desktop */

    /* Mobile adjustments */
    @media (max-width: 768px) and (orientation: portrait) {
      header h1 { font-size: 18px; }
      #hud { flex-wrap: wrap; justify-content: center; padding: 8px 12px calc(6px + var(--safe-bottom)) 12px; }
      #hud > span:first-child { display: none; } /* Hide literal 'Category:' label */
      #hud > span[style*='margin-left:auto'] { display: none !important; } /* Hide spacer */
      #category { font-size: 24px; max-width: 90vw; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
      #timeLabel { font-size: 16px; }
      #timer { font-size: 34px; }
      #timeBlock { position: static; transform: none; order: 3; width: 100%; display: flex; justify-content: center; }
      #wordForm { order: 4; width: 100%; display: flex; justify-content: center; gap: 8px; }
      #wordForm button { padding: 8px 10px; }
      #log { display: none !important; }
      #shuffleCatBtn { display: none; }
    }
  </style>
</head>
<body>
  
  <div id="app">
    <header>
      <h1>LexiOrbit</h1>
      <span class="chip" id="roundChip">Round 1</span>
      <a href="games.html" style="margin-left:auto;color:#93c5fd;text-decoration:none;padding:6px 10px;border:1px solid #475569;border-radius:8px;">All Games</a>
    </header>
    <div id="stage">
      <canvas id="gameCanvas"></canvas>
      <div id="log"></div>
    </div>
    <div id="hud">
      <span>Category:</span>
      <span id="category"></span>
      <span style="margin-left:auto"></span>
              <span id="timeBlock"><span id="timeLabel">Time:</span><span id="timer">12.0</span></span>
      <!-- removed heard chip UI -->
      <div id="wordForm" style="display:flex; gap:10px; align-items:center;">
        <button type="button" id="newRoundBtn">New Round</button>
        <button type="button" id="shuffleCatBtn">Shuffle Category</button>
        <button type="button" id="voiceBtn" title="Voice (beta)">🎤 Voice (beta)</button>
      </div>
    </div>
  </div>

  <script>
    console.log('Starting Tapple game with 2D Canvas...');
    const isMobile = /iPhone|Android|iPad|iPod/i.test(navigator.userAgent) || (Math.min(screen.width, screen.height) < 768);
    const isIOS = /iP(hone|od|ad)/i.test(navigator.platform) || (/iPhone|iPad|iPod/i.test(navigator.userAgent) && /Safari/i.test(navigator.userAgent) && !/Chrome/i.test(navigator.userAgent));

    // Voice (beta) — client-only using Web Speech API when available
    const SpeechRec = window.SpeechRecognition || window.webkitSpeechRecognition || null;
    let recognition = null;
    let voiceActive = false;
    let lastVoiceWord = '';
    let lastVoiceAt = 0;
    let lastClaimAt = 0;
    // MediaRecorder streaming + throttle to improve responsiveness
    let mrStream = null, mrRec = null;
    let sttBusy = false, sttLastAt = 0;
    let mrReqTimer = null, mrStopTimer = null;
    let heardHideTimer = null;
    let claimCooldownUntil = 0; // block multiple claims from one utterance
    function showHeard(text) { /* no-op per request */ }

    // Audio utils: encode 16 kHz mono WAV for better STT accuracy
    function writeString(view, offset, str) {
      for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i));
    }
    function encodeWav(float32Samples, sampleRate) {
      const numSamples = float32Samples.length;
      const bytesPerSample = 2; // 16-bit PCM
      const blockAlign = bytesPerSample * 1; // mono
      const byteRate = sampleRate * blockAlign;
      const dataSize = numSamples * bytesPerSample;
      const buffer = new ArrayBuffer(44 + dataSize);
      const view = new DataView(buffer);
      // RIFF header
      writeString(view, 0, 'RIFF');
      view.setUint32(4, 36 + dataSize, true);
      writeString(view, 8, 'WAVE');
      // fmt chunk
      writeString(view, 12, 'fmt ');
      view.setUint32(16, 16, true); // PCM chunk size
      view.setUint16(20, 1, true); // audio format PCM
      view.setUint16(22, 1, true); // channels: mono
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, byteRate, true);
      view.setUint16(32, blockAlign, true);
      view.setUint16(34, 16, true); // bits per sample
      // data chunk
      writeString(view, 36, 'data');
      view.setUint32(40, dataSize, true);
      // samples
      let offset = 44;
      for (let i = 0; i < numSamples; i++) {
        let s = Math.max(-1, Math.min(1, float32Samples[i] || 0));
        view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
        offset += 2;
      }
      return new Blob([buffer], { type: 'audio/wav' });
    }
    async function blobToWav16kMono(blob) {
      try {
        const arrayBuf = await blob.arrayBuffer();
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        const ac = new AudioCtx();
        const audioBuf = await ac.decodeAudioData(arrayBuf);
        // mono (use channel 0)
        const src = audioBuf.getChannelData(0);
        const srcRate = audioBuf.sampleRate || 44100;
        const targetRate = 16000;
        const ratio = srcRate / targetRate;
        const outLen = Math.max(1, Math.floor(src.length / ratio));
        const out = new Float32Array(outLen);
        for (let i = 0; i < outLen; i++) {
          const idx = i * ratio;
          const i0 = Math.floor(idx);
          const i1 = Math.min(src.length - 1, i0 + 1);
          const t = idx - i0;
          out[i] = src[i0] * (1 - t) + src[i1] * t;
        }
        await ac.close().catch(()=>{});
        return encodeWav(out, targetRate);
      } catch (e) {
        return null;
      }
    }
    function claimLetter(letter) {
      if (!gameState.gameActive) return;
      if (gameState.usedLetters.has(letter)) return;
      gameState.turnHasPressed = true;
      gameState.usedLetters.add(letter);
      gameState.selectedLetter = null;
      playSound('click');
      updateBackgroundForLetter(letter);
      drawGame();
      if (gameState.usedLetters.size === gameState.letters.length) {
        showLog('🎉 Perfect! All letters used!', 'victory');
        gameState.gameActive = false;
        const usedRaw = gameState.usedLetters.size;
        const cat = gameState.currentCategory;
        const distinct = new Set((CATEGORY_BANK[cat]||[]).map(w => w[0]?.toUpperCase())).size;
        const total = Math.min(20, distinct || gameState.letters.length);
        const used = Math.min(usedRaw, total);
        gameState.overlayMessage = 'Perfect! All letters used!';
        gameState.overlayScoreText = `Score: ${used}/${total} (${Math.round((used/total)*100)}%)`;
        backgroundWords = [];
        drawGame();
        (async ()=>{
          try{
            let player = localStorage.getItem('lexiorbit_player');
            if (!player) { player = 'Player-' + Math.floor(Math.random()*1e6).toString(36).toUpperCase(); localStorage.setItem('lexiorbit_player', player); }
            const resp = await fetch('/api/scores', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ player, used, total })});
            const data = await resp.json().catch(()=>null);
            if (data && data.top5) { window.__topScores = { top5: data.top5 }; drawGame(); } else { if (typeof fetchTopScores === 'function') fetchTopScores(); }
          }catch(e){}
        })();
        return;
      }
      startNextTurn();
    }

    function claimFromText(raw) {
      const text = (raw || '').trim();
      if (!text) return;
      const nowTs = Date.now();
      if (nowTs < claimCooldownUntil) { return; }
      // Normalize helpers and fuzzy matching
      const norm = (s) => (s || '').toLowerCase().replace(/[^a-z]/g, '');
      // Common expansions for STT mishearings
      const expand = (s) => s
        .replace(/&/g,'and')
        .replace(/^mc([a-z])/,'mc$1')
        .replace(/^st\s+/,'saint ')
        .replace(/\bnyc\b/,'newyork')
        .replace(/\bla\b/,'losangeles')
        .replace(/\bsf\b/,'sanfrancisco');
      const dist = (a, b) => {
        const m = a.length, n = b.length;
        if (m === 0) return n; if (n === 0) return m;
        // Early exit if very different
        if (Math.abs(m - n) > Math.ceil(Math.max(m, n) * 0.5)) return Math.max(m, n);
        const dp = new Array(n + 1);
        for (let j = 0; j <= n; j++) dp[j] = j;
        for (let i = 1; i <= m; i++) {
          let prev = dp[0]; dp[0] = i;
          for (let j = 1; j <= n; j++) {
            const temp = dp[j];
            if (a[i - 1] === b[j - 1]) dp[j] = prev;
            else dp[j] = Math.min(prev + 1, dp[j] + 1, dp[j - 1] + 1);
            prev = temp;
          }
        }
        return dp[n];
      };
      const bestFuzzyMatch = (tokens, bankWords) => {
        let best = null; // {word, score, bn}
        for (const tk of tokens) {
          const tn = norm(expand(tk));
          if (!tn) continue;
          for (const w of bankWords) {
            const bn = norm(expand(w));
            if (!bn) continue;
            const d = dist(tn, bn);
            // Slightly more tolerant for short words; stricter for long words
            const tol = Math.ceil(Math.max(2, Math.min(3, bn.length * 0.28)));
            if (d <= tol) {
              const score = d / Math.max(1, bn.length);
              if (!best || score < best.score) best = { word: w, score, bn };
            }
          }
        }
        return best;
      };
      // Build normalized bank map
      const cat = gameState.currentCategory;
      const bank = (CATEGORY_BANK[cat] || []).map(w => (w||'').toString());
      let matchedNorm = '';
      const tokens = text.split(/[^A-Za-z]+/).filter(Boolean);
      // Prefer exact token match against bank, in order
      const bankNormSet = new Set(bank.map(w => norm(expand(w))));
      for (const tk of tokens) {
        const tn = norm(expand(tk));
        if (tn && bankNormSet.has(tn)) { matchedNorm = tn; break; }
      }
      // Fallback to fuzzy on tokens only
      if (!matchedNorm) {
        const fuzzy = bestFuzzyMatch(tokens, bank);
        if (fuzzy) matchedNorm = fuzzy.bn;
      }
      if (!matchedNorm) { showHeard(text); return; }
      showHeard(text);
      // De-dupe same word within 1.5s (reduced for faster play)
      const now = Date.now();
      if (matchedNorm === lastVoiceWord && (now - lastVoiceAt) < 1500) return;
      lastVoiceWord = matchedNorm; lastVoiceAt = now;
      // Rate-limit claims to avoid double-claim on one utterance (reduced)
      if ((now - lastClaimAt) < 500) return;
      // Validate: match against normalized bank entries
      if (!bankNormSet.has(matchedNorm)) { showLog('Not a valid word for this category', 'error'); return; }
      const letter = matchedNorm[0] ? matchedNorm[0].toUpperCase() : '';
      // Only allow letters present on the board and not already used
      if (!gameState.letters.includes(letter)) { showLog(`"${letter}" not on board`, 'error'); return; }
      if (gameState.usedLetters.has(letter)) { showLog(`"${letter}" already used`, 'info'); return; }
      lastClaimAt = now;
      claimCooldownUntil = now + 1000; // Brief cooldown to prevent double-claims
      claimLetter(letter);
      // No need to rollover - keep listening continuously
    }

    function forceRecorderRollover() {
      try {
        if (mrRec && mrRec.state === 'recording') {
          mrRec.stop(); // onstop will auto-restart shortly
        }
      } catch {}
    }

    function initRecognition() {
      if (!SpeechRec || recognition) return;
      recognition = new SpeechRec();
      recognition.lang = 'en-US';
      recognition.interimResults = true;
      recognition.maxAlternatives = 1;
      recognition.continuous = true;
      recognition.onresult = (event) => {
        try {
          const last = event.results[event.results.length - 1];
          if (!last || !last[0]) return;
          const text = (last[0].transcript || '').trim();
          if (text) showHeard(text); // show ASAP, even interim
          if (last.isFinal && text) {
            claimFromText(text);
          }
        } catch {}
      };
      recognition.onerror = () => { /* keep running in beta; user can toggle */ };
      recognition.onend = () => { if (voiceActive && recognition) { try { recognition.start(); } catch {} } };
    }
    // Simple dictation overlay for iPhone Safari (no API key needed)
    function ensureDictationUI() {
      if (document.getElementById('dictationOverlay')) return;
      const overlay = document.createElement('div');
      overlay.id = 'dictationOverlay';
      overlay.style.position = 'fixed';
      overlay.style.inset = '0';
      overlay.style.background = 'rgba(2,6,23,0.92)';
      overlay.style.display = 'none';
      overlay.style.zIndex = '1000';
      overlay.style.color = '#e2e8f0';
      overlay.style.padding = '24px';
      overlay.style.boxSizing = 'border-box';
      overlay.innerHTML = `
        <div style="max-width:640px;margin:0 auto;display:flex;flex-direction:column;gap:16px;align-items:stretch;">
          <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;">
            <div style="font-size:20px;font-weight:800;color:#93c5fd;">Voice (iPhone dictation)</div>
            <button id="dictClose" style="border:2px solid #475569;background:#1e293b;color:#e2e8f0;padding:6px 10px;border-radius:8px;">Close</button>
          </div>
          <div style="font-size:14px;color:#cbd5e1;line-height:1.4;">
            - Tap the field below. If the keyboard doesn’t open, tap it again.<br/>
            - Tap the microphone on your iPhone keyboard and say a word.<br/>
            - We’ll capture the first letter and claim it automatically.
          </div>
          <input id="dictInput" type="text" autocapitalize="words" autocomplete="off" spellcheck="false" inputmode="text"
                 placeholder="Tap here, then tap the keyboard mic and speak..."
                 style="padding:14px 16px;border-radius:10px;border:2px solid #334155;background:#0f172a;color:#e2e8f0;font-size:18px;"/>
        </div>`;
      document.body.appendChild(overlay);
      const input = overlay.querySelector('#dictInput');
      const close = overlay.querySelector('#dictClose');
      close.addEventListener('click', () => { stopVoice(); });
      const handleDict = () => { const val = input.value; if (!val) return; claimFromText(val); input.value = ''; };
      input.addEventListener('input', handleDict);
      input.addEventListener('change', handleDict);
      input.addEventListener('keyup', (e) => { if (e.key === 'Enter') handleDict(); else handleDict(); });
      input.addEventListener('compositionend', handleDict);
      input.addEventListener('blur', () => { if (voiceActive) setTimeout(() => { try { input.focus(); } catch {} }, 0); });
      window.__dictationOverlay = overlay;
    }

    async function startVoice() {
      console.log('startVoice called');
      // Always try to acquire mic first (ensures Safari shows the permission prompt on user gesture)
      try {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) throw new Error('no mediaDevices');
        console.log('Getting user media...');
        mrStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        console.log('Got media stream:', mrStream);
        // Prefer Safari-supported types
        const candidates = [ 'audio/mp4', 'audio/webm;codecs=opus', 'audio/webm', 'audio/mpeg' ];
        let mt = '';
        for (const c of candidates) { 
          if (window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(c)) { 
            mt = c; 
            console.log('Using mime type:', mt);
            break; 
          } 
        }
        if (!window.MediaRecorder) throw new Error('MediaRecorder unsupported');
        const options = mt ? { mimeType: mt } : {};
        console.log('Creating MediaRecorder with options:', options);
        mrRec = new MediaRecorder(mrStream, options);
          mrRec.ondataavailable = async (e) => {
            console.log('ondataavailable fired, voiceActive:', voiceActive, 'data size:', e.data?.size);
            if (!voiceActive) return;
            
            // Process any non-empty chunk
            if (!e.data || e.data.size === 0) {
              console.log('No data or empty data');
              return;
            }
            
            const now = Date.now();
            if (sttBusy || (now - sttLastAt) < 300) {
              console.log('Skipping due to busy or rate limit');
              return;
            }
            
            sttBusy = true; sttLastAt = now;
            try {
              console.log('Processing audio chunk, size:', e.data.size, 'type:', e.data.type);
              const form = new FormData();
              const ext = mt.includes('mp4') ? 'mp4' : (mt.includes('mpeg') ? 'mp3' : 'webm');
              form.append('file', e.data, `clip.${ext}`);
              // Provide category hints to improve recognition fidelity
              try {
                const cat = gameState.currentCategory;
                const raw = (CATEGORY_BANK[cat] || []).slice(0, 120);
                const normalized = raw.map(w=>w.toLowerCase());
                const uniq = Array.from(new Set(normalized)).slice(0, 120);
                form.append('hints', uniq.join(', '));
              } catch {}
              // no HUD status
              console.log('Sending to STT endpoint...');
              const resp = await fetch('/api/stt', { method: 'POST', body: form, cache: 'no-store' });
              console.log('STT response status:', resp.status);
              const data = await resp.json().catch(()=>null);
              console.log('STT response data:', data);
              const text = (data && (data.text || '').trim()) || '';
              console.log('Extracted text:', text);
              if (text && text.length > 0) {
                showHeard(text); // show immediately
                claimFromText(text);
              } else {
                console.log('No text returned, continuing to listen');
              }
              // Always reset to listening after processing
              // keep listening silently
            } catch (err) {
              console.log('STT processing error:', err);
            }
            sttBusy = false;
        };
        mrRec.onerror = () => {};
        mrRec.onstart = () => {
          console.log('MediaRecorder started');
          // Use regular auto-stop/restart approach that works reliably on Safari
          if (mrReqTimer) clearInterval(mrReqTimer);
          if (mrStopTimer) clearTimeout(mrStopTimer);
          
          // Auto-stop recording after 1.5 seconds to generate data chunks
          mrStopTimer = setTimeout(() => {
            try {
              if (mrRec.state === 'recording') {
                console.log('Auto-stopping to generate chunk');
                mrRec.stop();
              }
            } catch {}
          }, 1500);
        };
        mrRec.onstop = () => {
          console.log('MediaRecorder stopped, voiceActive:', voiceActive);
          if (!voiceActive) return;
          // Restart after brief delay to continue listening
          console.log('Restarting recording in 100ms...');
          setTimeout(() => { 
            try { 
              if (voiceActive) mrRec.start(); 
            } catch {} 
          }, 100);
        };
          console.log('Starting initial recording');
          try { 
            mrRec.start(); // Start without timeslice, will auto-stop after 2s
          } catch {}
        voiceActive = true;
        const btn = document.getElementById('voiceBtn');
        if (btn) { btn.dataset.active = '1'; btn.style.borderColor = '#22c55e'; }
        // no HUD status
        return;
      } catch (e) {
        // If mic path fails, try browser SpeechRecognition if present
        if (SpeechRec) {
          initRecognition();
          try {
            recognition.start();
            voiceActive = true;
            const btn = document.getElementById('voiceBtn');
            if (btn) { btn.dataset.active = '1'; btn.style.borderColor = '#22c55e'; }
            // no HUD status
            return;
          } catch {}
        }
        // fallback to dictation overlay if mic not allowed
        if (e && (e.name === 'NotAllowedError' || e.name === 'NotFoundError')) {
          showLog('Microphone blocked. Enable mic for this site in Settings.', 'error');
        }
        ensureDictationUI();
        const o = window.__dictationOverlay; if (o) { o.style.display = 'block'; const input = o.querySelector('#dictInput'); try { input.focus(); } catch {} }
        voiceActive = true;
        const btn = document.getElementById('voiceBtn');
        if (btn) { btn.dataset.active = '1'; btn.style.borderColor = '#22c55e'; }
        showLog('Voice dictation ready. Tap keyboard mic to speak.', 'info');
        return;
      }
    }
    function stopVoice() {
      voiceActive = false;
      if (recognition) { try { recognition.stop(); } catch {} }
      if (window.__dictationOverlay) { 
        try { window.__dictationOverlay.style.display = 'none'; } catch {}
      }
      if (mrReqTimer) { clearInterval(mrReqTimer); mrReqTimer = null; }
      if (mrStopTimer) { clearTimeout(mrStopTimer); mrStopTimer = null; }
      if (mrRec) { try { mrRec.stop(); } catch {} }
      if (mrStream) { try { mrStream.getAudioTracks().forEach(t => t.stop()); } catch {} }
      mrRec = null; mrStream = null; sttBusy = false;
      // no HUD status
      const btn = document.getElementById('voiceBtn');
      if (btn) { btn.dataset.active = '0'; btn.style.borderColor = '#475569'; }
    }
    
    // Game state
    let gameState = {
      currentCategory: '',
      letters: 'ABCDEFGHIJKLMNOPQRST'.split(''),
      usedLetters: new Set(),
      timeLeft: 12.0,
      round: 1,
      gameActive: false,
      selectedLetter: null,
      // Per-turn state: whether a new letter was pressed during the current 12s window
      turnHasPressed: false,
      overlayMessage: '',
      overlayScoreText: '',
      warningTickerActive: false
    };

    // Default Top Players shown until server responds
    window.__topScores = {
      top5: [
        { player: 'Ofir', avg: 0.85 },
        { player: 'Dana', avg: 0.76 },
        { player: 'Avi', avg: 0.75 },
        { player: 'Noa', avg: 0.71 },
        { player: 'Lior', avg: 0.57 }
      ]
    };

    // Audio (iOS unlock + louder on mobile)
    let audioCtx;
    function getAudio() {
      if (!audioCtx) {
        const Ctx = window.AudioContext || window.webkitAudioContext;
        try { audioCtx = new Ctx(); } catch (e) { return null; }
      }
      if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
      return audioCtx;
    }
    function unlockAudioOnce() {
      const ctx = getAudio();
      if (!ctx) return;
      // short quiet ping to satisfy iOS gesture requirement
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.connect(g); g.connect(ctx.destination);
      const t = ctx.currentTime + 0.01;
      g.gain.setValueAtTime(0.0001, t);
      o.start(t); o.stop(t + 0.02);
    }
    window.addEventListener('touchend', unlockAudioOnce, { once: true, passive: true });
    window.addEventListener('pointerdown', unlockAudioOnce, { once: true });
    window.addEventListener('keydown', unlockAudioOnce, { once: true });

    function playSound(type) {
      const ctx = getAudio();
      if (!ctx) return;
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.connect(gain);
      gain.connect(ctx.destination);
      const now = ctx.currentTime;
      const isTick = (type === 'tick');
      const dur = isTick ? 0.14 : 0.32;
      const base = isMobile ? (isTick ? 0.22 : 0.18) : (isTick ? 0.12 : 0.12);
      gain.gain.setValueAtTime(base, now);
      gain.gain.exponentialRampToValueAtTime(0.004, now + dur);
      switch(type) {
        case 'click': osc.frequency.setValueAtTime(820, now); break;
        case 'success': osc.frequency.setValueAtTime(1250, now); break;
        case 'buzz': osc.frequency.setValueAtTime(180, now); break;
        case 'start': osc.frequency.setValueAtTime(640, now); break;
        case 'tick': osc.frequency.setValueAtTime(2100, now); break;
      }
      osc.start(now);
      osc.stop(now + (isTick ? 0.1 : 0.3));
    }

    // Warning ticker that beeps as a turn is about to end
    let warningInterval = null;
    function startWarningTicker() {
      if (gameState.warningTickerActive) return;
      gameState.warningTickerActive = true;
      warningInterval = setInterval(() => {
        if (!gameState.gameActive) return;
        playSound('tick');
      }, 250);
    }
    function stopWarningTicker() {
      if (warningInterval) clearInterval(warningInterval);
      warningInterval = null;
      gameState.warningTickerActive = false;
    }

    // Background word data per category (sampled lists)
    const BASE_BANK = {
      'Animals': ['Antelope','Aardvark','Albatross','Bear','Buffalo','Beaver','Cat','Cougar','Cheetah','Dog','Dolphin','Deer','Eagle','Eel','Emu','Fox','Falcon','Giraffe','Goat','Horse','Hare','Hedgehog','Iguana','Impala','Jaguar','Jay','Kangaroo','Koala','Lion','Lemur','Leopard','Monkey','Moose','Newt','Nightingale','Owl','Otter','Panda','Penguin','Quail','Quokka','Rabbit','Raccoon','Shark','Sheep','Tiger','Turtle','Urchin','Vulture','Wolf','Walrus','Xerus','Yak','Zebra'],
      'Food & Drink': ['Apple','Avocado','Bagel','Bread','Burger','Cake','Cookie','Dumpling','Donut','Egg','Edamame','Falafel','Fried Rice','Grape','Granola','Hummus','Honey','Ice Tea','Ice Cream','Juice','Jam','Kebab','Kale','Lemonade','Lasagna','Mango','Muffin','Noodles','Nachos','Orange','Omelet','Pizza','Pasta','Quiche','Quesadilla','Ramen','Risotto','Sushi','Salad','Taco','Toast','Udon','Ugali','Vanilla','Veggies','Waffle','Walnut','Xacuti','Yogurt','Ziti'],
      'Countries': ['Argentina','Australia','Austria','Brazil','Belgium','Canada','Chile','China','Colombia','Denmark','Dominican Republic','Egypt','Estonia','Finland','France','Germany','Greece','Hungary','Iceland','India','Indonesia','Ireland','Israel','Italy','Japan','Jordan','Kenya','Kuwait','Lebanon','Luxembourg','Mexico','Morocco','Netherlands','New Zealand','Nigeria','Norway','Oman','Pakistan','Peru','Philippines','Poland','Portugal','Qatar','Romania','Russia','Saudi Arabia','Singapore','South Africa','Spain','Sweden','Switzerland','Thailand','Turkey','Uganda','Ukraine','United Kingdom','United States','Uruguay','Venezuela','Vietnam'],
      'Movies': ['Avatar','Alien','Amelie','Batman','Braveheart','Casablanca','Coco','Dune','Drive','Eternals','Ex Machina','Frozen','Ford v Ferrari','Gladiator','Gravity','Heat','Her','Inception','Interstellar','Joker','Jaws','Kill Bill','King Kong','Lion King','Logan','Matrix','Mad Max','Nope','Oblivion','Parasite','Prestige','Pulp Fiction','Quantum of Solace','Ratatouille','Rocky','Skyfall','Spirited Away','Titanic','Top Gun','Up','Unforgiven','Vertigo','Whiplash','X-Men','Yesterday','Zodiac'],
      'Sports': ['Archery','Athletics','Badminton','Baseball','Basketball','Boxing','Cricket','Cycling','Diving','Equestrian','Fencing','Football','Golf','Gymnastics','Handball','Hockey','Ice Hockey','Judo','Karate','Kayaking','Lacrosse','Motorsport','Netball','Rowing','Rugby','Sailing','Skiing','Snowboarding','Surfing','Swimming','Table Tennis','Taekwondo','Tennis','Triathlon','Volleyball','Water Polo','Wrestling'],
      'Colors': ['Amber','Aqua','Beige','Black','Blue','Bronze','Crimson','Cyan','Cerulean','Emerald','Fuchsia','Gold','Gray','Green','Indigo','Ivory','Jade','Khaki','Lavender','Lime','Magenta','Maroon','Navy','Olive','Orange','Peach','Pink','Purple','Red','Rose','Scarlet','Silver','Teal','Turquoise','Ultramarine','Violet','White','Yellow'],
      'Professions': ['Accountant','Architect','Artist','Baker','Barber','Biologist','Carpenter','Chef','Chemist','Dentist','Designer','Doctor','Driver','Engineer','Electrician','Farmer','Firefighter','Gardener','Geologist','Judge','Journalist','Lawyer','Librarian','Mechanic','Nurse','Optician','Painter','Pharmacist','Photographer','Pilot','Plumber','Programmer','Scientist','Singer','Teacher','Translator','Veterinarian','Writer'],
      'School Supplies': ['Agenda','Backpack','Binder','Book','Calculator','Chalk','Compass','Crayons','Eraser','Folder','Glue','Highlighter','Index Cards','Markers','Notebook','Paper','Pen','Pencil','Protractor','Ruler','Scissors','Stapler','Tape'],
      'Clothing': ['Anorak','Apron','Blazer','Boots','Cap','Coat','Dress','Gloves','Hat','Hoodie','Jeans','Jacket','Kimono','Leggings','Pajamas','Pants','Raincoat','Scarf','Shirt','Shoes','Shorts','Skirt','Suit','Sweater','T-Shirt','Tie','Underwear','Vest'],
      'Musical Instruments': ['Accordion','Banjo','Bassoon','Cello','Clarinet','Drum','Euphonium','Flute','Gong','Guitar','Harp','Horn','Ivory Keys','Jarana','Keyboard','Lute','Mandolin','Nyckelharpa','Oboe','Organ','Piano','Qanun','Recorder','Saxophone','Trombone','Trumpet','Tuba','Ukulele','Viola','Violin','Whistle','Xylophone','Yueqin','Zither'],
      'Things in the Kitchen': ['Apron','Bowl','Bottle','Cup','Colander','Dish','Drawer','Egg Timer','Fork','Frying Pan','Grater','Glass','Jar','Jug','Knife','Kettle','Ladle','Mug','Microwave','Oven','Plate','Pot','Pan','Peeler','Rolling Pin','Sieve','Spatula','Spoon','Toaster','Tongs','Whisk'],
      'Board Games': ['Azul','Blokus','Carcassonne','Catan','Chess','Clank','Dominion','Everdell','Exploding Kittens','Go','Gloomhaven','Hive','Innovation','Jaipur','Kingdomino','Love Letter','Monopoly','Pandemic','Patchwork','Qwirkle','Risk','Scythe','Scrabble','Splendor','Terraforming Mars','Ticket to Ride','Uno','Viticulture','Wingspan','Zombicide'],
      'TV Shows': ['Arrow','Barry','Breaking Bad','Community','Chernobyl','Dexter','Dark','Euphoria','Friends','Fargo','Game of Thrones','Hannibal','House','Invincible','Justified','Lost','Loki','Mad Men','Narcos','Office','Ozark','Peaky Blinders','Prison Break','Queen’s Gambit','Raised by Wolves','Sherlock','Severance','Sopranos','Succession','Ted Lasso','The Wire','Vikings','Westworld','Yellowjackets'],
      'Books': ['Animal Farm','Beowulf','Catch-22','Dune','Emma','Fahrenheit 451','Gatsby','Hamlet','Iliad','Jane Eyre','King Lear','Les Miserables','Macbeth','Narnia','Odyssey','Pride and Prejudice','Rebecca','Siddhartha','Ulysses','War and Peace','Wuthering Heights'],
      'Superheroes': ['Ant-Man','Aquaman','Batman','Black Panther','Black Widow','Captain America','Captain Marvel','Cyclops','Daredevil','Doctor Strange','Flash','Green Lantern','Hawkeye','Hulk','Iron Man','Jean Grey','Jubilee','Jessica Jones','Luke Cage','Ms Marvel','Nightcrawler','Quicksilver','Robin','Scarlet Witch','Spider-Man','Star-Lord','Storm','Superman','Thor','Wasp','Wolverine','Wonder Woman','Zatanna'],
      'Car Brands': ['Acura','Alfa Romeo','Aston Martin','Audi','Bentley','BMW','Bugatti','Cadillac','Chevrolet','Chrysler','Citroen','Dacia','Dodge','Ferrari','Fiat','Ford','GMC','Honda','Hyundai','Infiniti','Isuzu','Jaguar','Jeep','Kia','Lamborghini','Land Rover','Lexus','Lincoln','Maserati','Mazda','McLaren','Mercedes','Mini','Mitsubishi','Nissan','Opel','Peugeot','Porsche','Renault','Rolls-Royce','Seat','Skoda','Subaru','Suzuki','Tesla','Toyota','Volkswagen','Volvo'],
      'Fruits': ['Apple','Apricot','Avocado','Banana','Blackberry','Blueberry','Cherry','Coconut','Cranberry','Date','Durian','Elderberry','Fig','Grape','Grapefruit','Guava','Honeydew','Jackfruit','Kiwi','Kumquat','Lemon','Lime','Lychee','Mango','Mulberry','Nectarine','Orange','Papaya','Peach','Pear','Persimmon','Pineapple','Plum','Pomegranate','Quince','Raspberry','Strawberry','Tangerine','Ugli fruit','Watermelon','Yuzu','Ziziphus'],
      'Vegetables': ['Artichoke','Asparagus','Beetroot','Broccoli','Brussels Sprout','Cabbage','Carrot','Cauliflower','Celery','Corn','Daikon','Eggplant','Endive','Fennel','Garlic','Ginger','Horseradish','Iceberg Lettuce','Jalapeno','Jicama','Kale','Leek','Lettuce','Mushroom','Okra','Onion','Parsnip','Pea','Pepper','Potato','Pumpkin','Radish','Rutabaga','Spinach','Squash','Turnip','Ube','Watercress','Yam','Zucchini'],
      'Dog Breeds': ['Akita','Beagle','Border Collie','Bulldog','Chihuahua','Corgi','Dalmatian','Doberman','Eskimo Dog','French Bulldog','German Shepherd','Golden Retriever','Greyhound','Husky','Irish Setter','Jack Russell Terrier','Keeshond','Labrador Retriever','Maltese','Mastiff','Newfoundland','Old English Sheepdog','Poodle','Pug','Rottweiler','Samoyed','Shiba Inu','Shih Tzu','Terrier','Vizsla','Weimaraner','Whippet','Xoloitzcuintli','Yorkshire Terrier','Zuchon'],
      'Birds': ['Albatross','Bluebird','Canary','Crane','Dove','Duck','Eagle','Egret','Falcon','Finch','Goose','Gull','Hawk','Heron','Ibis','Jay','Kingfisher','Kite','Lark','Magpie','Nightingale','Osprey','Owl','Parrot','Pelican','Quail','Raven','Robin','Sparrow','Starling','Swallow','Swan','Tern','Toucan','Vulture','Warbler','Woodpecker','Xantus Hummingbird','Yellowhammer','Zebra Finch'],
      'Languages': ['Arabic','Bengali','Chinese','Dutch','English','French','German','Hindi','Italian','Japanese','Korean','Lithuanian','Malay','Nepali','Oromo','Persian','Polish','Portuguese','Quechua','Russian','Spanish','Swahili','Turkish','Ukrainian','Urdu','Vietnamese','Welsh','Xhosa','Yoruba','Zulu'],
      'Elements': ['Actinium','Aluminium','Americium','Argon','Arsenic','Barium','Beryllium','Bismuth','Boron','Bromine','Cadmium','Calcium','Carbon','Cerium','Chlorine','Chromium','Cobalt','Copper','Curium','Dubnium','Dysprosium','Einsteinium','Erbium','Europium','Fluorine','Francium','Gadolinium','Gallium','Germanium','Gold','Hafnium','Helium','Holmium','Hydrogen','Indium','Iodine','Iridium','Iron','Krypton','Lanthanum','Lithium','Magnesium','Manganese','Mercury','Molybdenum','Neon','Nickel','Niobium','Nitrogen','Osmium','Oxygen','Palladium','Phosphorus','Platinum','Plutonium','Potassium','Radium','Radon','Rhenium','Rhodium','Rubidium','Ruthenium','Samarium','Scandium','Selenium','Silicon','Silver','Sodium','Strontium','Sulfur','Tantalum','Technetium','Tellurium','Terbium','Thallium','Thorium','Thulium','Tin','Titanium','Tungsten','Uranium','Vanadium','Xenon','Ytterbium','Yttrium','Zinc','Zirconium'],
      'US States': ['Alabama','Alaska','Arizona','Arkansas','California','Colorado','Connecticut','Delaware','Florida','Georgia','Hawaii','Idaho','Illinois','Indiana','Iowa','Kansas','Kentucky','Louisiana','Maine','Maryland','Massachusetts','Michigan','Minnesota','Mississippi','Missouri','Montana','Nebraska','Nevada','New Hampshire','New Jersey','New Mexico','New York','North Carolina','North Dakota','Ohio','Oklahoma','Oregon','Pennsylvania','Rhode Island','South Carolina','South Dakota','Tennessee','Texas','Utah','Vermont','Virginia','Washington','West Virginia','Wisconsin','Wyoming'],
      'World Capitals': ['Abuja','Accra','Addis Ababa','Algiers','Amman','Ankara','Antananarivo','Athens','Baghdad','Baku','Bamako','Bangkok','Beijing','Beirut','Belgrade','Berlin','Bern','Bogota','Brasilia','Bratislava','Brazzaville','Brussels','Bucharest','Budapest','Buenos Aires','Cairo','Canberra','Caracas','Chisinau','Colombo','Conakry','Copenhagen','Dakar','Damascus','Dhaka','Doha','Dublin','Edinburgh','Hanoi','Harare','Havana','Helsinki','Islamabad','Jakarta','Kabul','Kampala','Kathmandu','Khartoum','Kigali','Kiev','Kuala Lumpur','Kuwait City','La Paz','Lima','Lisbon','Ljubljana','London','Luanda','Lusaka','Madrid','Manila','Maputo','Marrakesh','Minsk','Mogadishu','Monaco','Montevideo','Moscow','Muscat','Nairobi','New Delhi','Nicosia','Oslo','Ottawa','Paris','Phnom Penh','Podgorica','Prague','Pretoria','Quito','Rabat','Reykjavik','Riyadh','Rome','Sana\'a','Santiago','Seoul','Singapore','Skopje','Sofia','Stockholm','Suva','Taipei','Tallinn','Tashkent','Tbilisi','Tegucigalpa','Tehran','Tokyo','Tripoli','Tunis','Ulaanbaatar','Vaduz','Valletta','Vienna','Vientiane','Vilnius','Warsaw','Wellington','Windhoek','Yerevan','Zagreb'],
      'Flowers': ['Azalea','Begonia','Carnation','Daffodil','Edelweiss','Freesia','Gardenia','Hibiscus','Hyacinth','Hydrangea','Iris','Jasmine','Kalanchoe','Lavender','Lilac','Lily','Marigold','Nasturtium','Orchid','Peony','Petunia','Poppy','Queen Anne\'s Lace','Rose','Sunflower','Tulip','Verbena','Violet','Wisteria','Yarrow','Zinnia'],
      'Desserts': ['Apple Pie','Baklava','Brownie','Cheesecake','Churro','Donut','Eclair','Flan','Gelato','Halva','Ice Cream','Jelly Roll','Key Lime Pie','Lava Cake','Mochi','Nougat','Opera Cake','Panna Cotta','Pavlova','Pudding','Quindim','Roulade','Sorbet','Tiramisu','Trifle','Upside-Down Cake','Waffle','Yogurt Parfait','Zeppole']
    };
    // Five more rich categories
    BASE_BANK['Music Genres'] = ['Ambient','Afrobeat','Bluegrass','Blues','Bossa Nova','Classical','Country','Dance','Disco','Dub','Dubstep','EDM','Electro','Folk','Funk','Gospel','Grime','Grunge','Hard Rock','Hip Hop','House','Industrial','Jazz','J-Pop','K-Pop','Latin','Metal','Opera','Pop','Punk','R&B','Rap','Reggae','Rock','Salsa','Ska','Soul','Techno','Trance'];
    BASE_BANK['Trees'] = ['Alder','Ash','Aspen','Baobab','Beech','Birch','Cedar','Chestnut','Cypress','Dogwood','Eucalyptus','Elm','Fir','Ginkgo','Hawthorn','Ironwood','Juniper','Kapok','Larch','Mahogany','Maple','Neem','Oak','Olive','Palm','Pine','Poplar','Quercus','Redwood','Sequoia','Spruce','Sycamore','Tamarind','Teak','Umbrella Thorn','Walnut','Willow','Yew','Zelkova'];
    BASE_BANK['Sea Creatures'] = ['Anglerfish','Barracuda','Clam','Crab','Damselfish','Dolphin','Eel','Grouper','Halibut','Isopod','Jellyfish','Krill','Lobster','Manta Ray','Moray Eel','Nudibranch','Octopus','Orca','Parrotfish','Quahog','Ray','Seahorse','Sea Turtle','Shrimp','Shark','Squid','Starfish','Stingray','Urchin','Vampire Squid','Whale','Wrasse','Xiphias','Yellowtail','Zebra Shark'];
    BASE_BANK['Accessories'] = ['Backpack','Belt','Beret','Bow Tie','Bracelet','Brooch','Cap','Cufflinks','Earrings','Glasses','Gloves','Hairclip','Handbag','Hat','Headband','Necklace','Ring','Scarf','Shawl','Stockings','Suspenders','Tie','Umbrella','Wallet','Watch'];
    BASE_BANK['Spices & Herbs'] = ['Allspice','Anise','Basil','Bay Leaf','Cardamom','Caraway','Chili','Chives','Cilantro','Cinnamon','Clove','Coriander','Cumin','Dill','Fennel','Fenugreek','Garlic','Ginger','Horseradish','Lavender','Mace','Mint','Mustard','Nutmeg','Oregano','Paprika','Parsley','Pepper','Rosemary','Saffron','Sage','Sumac','Tarragon','Thyme','Turmeric','Wasabi'];
    // Expand to 100+ categories by adding region/thematic variants of well-known bases
    const CATEGORY_BANK = { ...BASE_BANK };
    const regionVariants = ['in Africa','in Asia','in Europe','in North America','in South America','in Oceania','in the Middle East'];
    // Countries by region (representative lists; sufficient coverage for gameplay)
    /* Remove regional country categories per request
    const REGION_COUNTRIES = {
      'Africa': ['Algeria','Angola','Benin','Botswana','Burkina Faso','Burundi','Cameroon','Cape Verde','Central African Republic','Chad','Comoros','Congo','Democratic Republic of the Congo','Djibouti','Egypt','Equatorial Guinea','Eritrea','Eswatini','Ethiopia','Gabon','Gambia','Ghana','Guinea','Guinea-Bissau','Ivory Coast','Kenya','Lesotho','Liberia','Libya','Madagascar','Malawi','Mali','Mauritania','Mauritius','Morocco','Mozambique','Namibia','Niger','Nigeria','Rwanda','São Tomé and Príncipe','Senegal','Seychelles','Sierra Leone','Somalia','South Africa','South Sudan','Sudan','Tanzania','Togo','Tunisia','Uganda','Zambia','Zimbabwe'],
      'Asia': ['Afghanistan','Armenia','Azerbaijan','Bahrain','Bangladesh','Bhutan','Brunei','Cambodia','China','Cyprus','Georgia','India','Indonesia','Iran','Iraq','Israel','Japan','Jordan','Kazakhstan','Kuwait','Kyrgyzstan','Laos','Lebanon','Malaysia','Maldives','Mongolia','Myanmar','Nepal','North Korea','Oman','Pakistan','Palestine','Philippines','Qatar','Russia','Saudi Arabia','Singapore','South Korea','Sri Lanka','Syria','Taiwan','Tajikistan','Thailand','Timor-Leste','Turkey','Turkmenistan','United Arab Emirates','Uzbekistan','Vietnam','Yemen'],
      'Europe': ['Albania','Andorra','Austria','Belarus','Belgium','Bosnia and Herzegovina','Bulgaria','Croatia','Cyprus','Czech Republic','Denmark','Estonia','Finland','France','Germany','Greece','Hungary','Iceland','Ireland','Italy','Kosovo','Latvia','Liechtenstein','Lithuania','Luxembourg','Malta','Moldova','Monaco','Montenegro','Netherlands','North Macedonia','Norway','Poland','Portugal','Romania','San Marino','Serbia','Slovakia','Slovenia','Spain','Sweden','Switzerland','Ukraine','United Kingdom','Vatican City'],
      'North America': ['Antigua and Barbuda','Bahamas','Barbados','Belize','Canada','Costa Rica','Cuba','Dominica','Dominican Republic','El Salvador','Grenada','Guatemala','Haiti','Honduras','Jamaica','Mexico','Nicaragua','Panama','Saint Kitts and Nevis','Saint Lucia','Saint Vincent and the Grenadines','Trinidad and Tobago','United States'],
      'South America': ['Argentina','Bolivia','Brazil','Chile','Colombia','Ecuador','Guyana','Paraguay','Peru','Suriname','Uruguay','Venezuela'],
      'Oceania': ['Australia','Fiji','Kiribati','Marshall Islands','Micronesia','Nauru','New Zealand','Palau','Papua New Guinea','Samoa','Solomon Islands','Tonga','Tuvalu','Vanuatu'],
      'the Middle East': ['Bahrain','Cyprus','Egypt','Iran','Iraq','Israel','Jordan','Kuwait','Lebanon','Oman','Palestine','Qatar','Saudi Arabia','Syria','Turkey','United Arab Emirates','Yemen']
    };
    regionVariants.forEach(v => { const key = v.replace('in ',''); if (REGION_COUNTRIES[key]) CATEGORY_BANK[`Countries ${v}`] = REGION_COUNTRIES[key]; });
    */

    // Add 5 fresh creative, broad categories with rich A–Z coverage
    CATEGORY_BANK['Famous Landmarks'] = ['Acropolis','Angkor Wat','Big Ben','Brandenburg Gate','Burj Khalifa','Christ the Redeemer','Colosseum','Eiffel Tower','Great Barrier Reef','Great Wall','Golden Gate Bridge','Hagia Sophia','Iguazu Falls','Jerusalem Old City','Kremlin','Leaning Tower of Pisa','Machu Picchu','Mount Fuji','Niagara Falls','Petra','Pyramids of Giza','Sagrada Familia','Stonehenge','Sydney Opera House','Taj Mahal','Uluru','Victoria Falls','Yellowstone','Zion National Park'];
    CATEGORY_BANK['Space Missions'] = ['Apollo','Artemis','BepiColombo','Cassini','Chandrayaan','Dawn','Galileo','Gemini','Hayabusa','Juno','Kepler','Luna','Mars Express','Messenger','New Horizons','OSIRIS-REx','Pioneer','Rosetta','Soyuz','Sputnik','Tianwen','Vega','Voyager','Viking'];
    CATEGORY_BANK['Mythical Creatures'] = ['Banshee','Basilisk','Centaur','Cerberus','Cyclops','Dragon','Dryad','Elf','Fairy','Griffin','Gorgon','Hydra','Imp','Jinn','Kraken','Leprechaun','Mermaid','Minotaur','Nymph','Ogre','Pegasus','Phoenix','Selkie','Siren','Sprite','Troll','Unicorn','Valkyrie','Werewolf','Wyvern','Yeti','Ziz'];
    CATEGORY_BANK['Cooking Verbs'] = ['Bake','Blend','Boil','Broil','Caramelize','Chop','Dice','Ferment','Fry','Grate','Grill','Knead','Marinate','Mix','Poach','Roast','Saute','Sear','Season','Simmer','Slice','Steam','Stir','Toast','Whisk','Zest'];
    CATEGORY_BANK['Tools'] = ['Axe','Anvil','Brace','Chisel','Clamp','Crimper','Crowbar','Drill','File','Hammer','Hacksaw','Jigsaw','Knife','Level','Mallet','Measuring Tape','Pliers','Plane','Rasp','Router','Saw','Screwdriver','Sledgehammer','Soldering Iron','Square','Trowel','Vise','Wrench'];

    // Five more interesting categories
    CATEGORY_BANK['Programming Languages'] = [
      'Ada','Assembly','Bash','C','C++','C#','Clojure','COBOL','D','Dart','Elixir','Erlang','F#','Fortran','Go','Groovy','Haskell','HTML','Java','JavaScript','Julia','Kotlin','Lisp','Lua','Matlab','Nim','Objective-C','OCaml','Perl','PHP','Python','Q#','R','Ruby','Rust','Scala','Shell','Swift','TypeScript','V','VB.NET','Visual Basic','Wolfram','XQuery','Zig'
    ];
    CATEGORY_BANK['Board Game Mechanics'] = [
      'Area Control','Auction','Bag Building','Bluffing','Card Drafting','Cooperative','Deck Building','Dice Rolling','Engine Building','Hand Management','Hidden Movement','I Cut You Choose','Legacy','Modular Board','Negotiation','Pattern Building','Pick-up and Deliver','Press Your Luck','Route Building','Set Collection','Simultaneous Action','Tile Placement','Trick Taking','Variable Player Powers','Worker Placement'
    ];
    CATEGORY_BANK['Famous Painters'] = [
      'Anselm Kiefer','Botticelli','Caravaggio','Da Vinci','Dali','El Greco','Frida Kahlo','Goya','Hokusai','Ingres','Jackson Pollock','Kandinsky','Leonardo','Monet','Matisse','Norman Rockwell','O\'Keeffe','Picasso','Rembrandt','Renoir','Seurat','Titian','Turner','Utrillo','Vermeer','Van Gogh','Warhol','Whistler','Xu Beihong','Yves Klein','Zao Wou-Ki'
    ];
    CATEGORY_BANK['Fictional Characters'] = [
      'Aragorn','Batman','Catwoman','Dumbledore','Eowyn','Frodo','Gandalf','Hermione','Iron Man','Jon Snow','Katniss','Legolas','Mario','Neo','Optimus Prime','Pooh','Quasimodo','R2-D2','Sherlock','Spock','Thor','Tyrion','Ultron','Vader','Wolverine','Xena','Yoda','Zorro'
    ];
    CATEGORY_BANK['Famous Brands & Companies'] = [
      'Apple','Adobe','Amazon','Boeing','BMW','Cisco','Canon','Dell','Disney','eBay','Exxon','Facebook','Ford','Google','GE','Huawei','IBM','Intel','Johnson & Johnson','Kellogg\'s','LG','LinkedIn','Microsoft','Nokia','Netflix','Oracle','Pepsi','Qualcomm','Reddit','Samsung','Shell','Sony','Tesla','Tencent','Uber','Unilever','Visa','Volkswagen','Walmart','Xerox','Yahoo','Zara'
    ];

    // Categories: keep only those with at least 10-letter coverage in CATEGORY_BANK
    const categories = Object.keys(CATEGORY_BANK)
      .filter(cat => {
        const words = CATEGORY_BANK[cat] || [];
        const letters = new Set(words.map(w => (w && w[0] ? w[0].toUpperCase() : '')));
        letters.delete('');
        return letters.size >= 10;
      })
      .sort();

    // Canvas setup
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    let backgroundWords = [];
    let bgLayout = null; // cached [{x,y,rot,size,word}]
    let bgKey = '';
    let bgDims = { w: 0, h: 0 };
    function resetBgLayout() { bgLayout = null; bgKey = ''; }
    function computeBgLayout(wordsToDraw, cssW, cssH) {
      const sprites = [];
      const count = isMobile ? 14 : 48;
      for (let i = 0; i < count; i++) {
        // Make mobile background words larger for better readability
        const size = isMobile ? Math.floor(26 + Math.random() * 44) : Math.floor(24 + Math.random() * 64);
        const x = Math.random() * cssW;
        const y = Math.random() * cssH * (isMobile ? 0.6 : 0.8);
        const rot = (Math.random() - 0.5) * 0.35;
        const word = wordsToDraw[Math.floor(Math.random() * wordsToDraw.length)];
        sprites.push({ x, y, rot, size, word });
      }
      return sprites;
    }
    function updateBackgroundForLetter(letter) {
      const cat = gameState.currentCategory;
      const bank = CATEGORY_BANK[cat] || [];
      const words = bank.filter(w => w.toUpperCase().startsWith(letter.toUpperCase()));
      const fallback = Array.from({length: 6}, () => letter.toUpperCase());
      const base = (words.length ? words : fallback);
      // Expand to many entries for a richer background
      backgroundWords = [];
      for (let i = 0; i < 6; i++) backgroundWords.push(...base);
    }
    function updateBackgroundForUnpressed(unusedLettersSet) {
      const cat = gameState.currentCategory;
      const bank = CATEGORY_BANK[cat] || [];
      const list = [];
      for (const word of bank) {
        if (!word || typeof word !== 'string') continue;
        const first = word[0].toUpperCase();
        if (unusedLettersSet.has(first)) list.push(word);
      }
      backgroundWords = [];
      if (list.length === 0) {
        // fallback: repeat unused letters
        const letters = Array.from(unusedLettersSet);
        for (let i = 0; i < 20; i++) backgroundWords.push(...letters);
      } else {
        for (let i = 0; i < 4; i++) backgroundWords.push(...list);
      }
      resetBgLayout();
    }
    
    // Game board parameters (computed on resize for responsiveness and HiDPI)
    let BOARD_RADIUS = 150;
    let LETTER_RADIUS = 20;
    let CENTER_RADIUS = 44; // clickable Start button area
    let centerX, centerY, DPR = 1;

    function resizeCanvas() {
      const rect = canvas.parentElement.getBoundingClientRect();
      // iOS Safari can misreport DPR; clamp to 2 for performance and consistency on phones
      const rawDpr = window.devicePixelRatio || 1;
      DPR = Math.min(isMobile ? Math.max(1.5, rawDpr) : rawDpr, isMobile ? 2 : 3);
      // Set the internal pixel size for sharp rendering
      canvas.width = Math.max(1, Math.floor(rect.width * DPR));
      canvas.height = Math.max(1, Math.floor(rect.height * DPR));
      // Keep CSS size in layout pixels
      canvas.style.width = rect.width + 'px';
      canvas.style.height = rect.height + 'px';
      // Scale drawing operations from CSS px → device px
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

      // Center the board in CSS pixels (nudge down slightly on mobile to avoid header/instructions overlap)
      centerX = rect.width / 2;
      centerY = rect.height / 2 + (isMobile ? Math.floor(rect.height * 0.045) : 0);

      // Size board relative to shortest screen side (tighter fit on mobile)
      const minSide = Math.min(rect.width, rect.height);
      const scale = isMobile ? 0.44 : 0.33; // on phones push letters closer to edge to give more arc spacing
      BOARD_RADIUS = Math.max(120, Math.floor(minSide * scale));
      // Derive LETTER_RADIUS from arc spacing so letters do not overlap on mobile
      const perLetterArc = (2 * Math.PI * BOARD_RADIUS) / gameState.letters.length; // circumference per letter
      if (isMobile) {
        // Increase mobile letter size by additional ~15% while keeping safe spacing
        const baseFrac = 0.32; // fraction of per-letter arc used for radius baseline
        let frac = baseFrac * 1.32 * 1.15; // previous mobile boost (1.32) plus +15%
        frac = Math.min(frac, 0.45); // cap to avoid overlap (radius <= 45% of arc; diameter <= 90%)
        const sideFrac = 0.055 * 1.32 * 1.15; // scale side clamp similarly
        LETTER_RADIUS = Math.max(14, Math.min(Math.floor(perLetterArc * frac), Math.floor(minSide * sideFrac)));
        CENTER_RADIUS = Math.max(48, Math.floor(BOARD_RADIUS * 0.26));
      } else {
        LETTER_RADIUS = Math.max(22, Math.floor(BOARD_RADIUS * 0.12));
        CENTER_RADIUS = Math.max(40, Math.floor(BOARD_RADIUS * 0.24));
      }

      console.log(`Canvas resized dpr=${DPR}: ${rect.width}x${rect.height} css, center: (${centerX}, ${centerY}), boardR=${BOARD_RADIUS}`);
      drawGame();
    }

    function drawGame() {
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Background: gradient sky + faint words
      const cssW = Math.round(canvas.width / DPR), cssH = Math.round(canvas.height / DPR);
      const sky = ctx.createLinearGradient(0, 0, 0, cssH);
      sky.addColorStop(0, '#0b1220');
      sky.addColorStop(1, '#0e1a2f');
      ctx.fillStyle = sky;
      ctx.fillRect(0, 0, cssW, cssH);
      
      const defaultSkyWords = ['Ideas','Creativity','Swift','Harmony','Quest','Logic','Music','Ocean','Galaxy','Breeze','Spark','Photon','Pixel','Orbit','Echo','Nova','Pulse','Dream','Motion','Focus'];
      ctx.save();
      // Make mobile background suggestions less faint
      ctx.globalAlpha = isMobile ? 0.12 : 0.08;
      const wordsToDraw = (backgroundWords && backgroundWords.length) ? backgroundWords : defaultSkyWords;
      const key = `${wordsToDraw.length}:${wordsToDraw.slice(0,50).join('|')}`;
      if (!bgLayout || bgKey !== key || bgDims.w !== cssW || bgDims.h !== cssH) {
        bgLayout = computeBgLayout(wordsToDraw, cssW, cssH);
        bgKey = key;
        bgDims = { w: cssW, h: cssH };
      }
      for (const s of bgLayout) {
        ctx.save();
        ctx.translate(s.x, s.y);
        ctx.rotate(s.rot);
        ctx.fillStyle = '#cbd5e1';
        ctx.font = `${s.size}px Segoe UI, Arial, sans-serif`;
        ctx.fillText(s.word, 0, 0);
        ctx.restore();
      }
      ctx.globalAlpha = 1;
      ctx.restore();
      
      // Draw outer ring
      ctx.strokeStyle = '#60a5fa';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(centerX, centerY, BOARD_RADIUS + 10, 0, Math.PI * 2);
      ctx.stroke();
      
      // Draw inner ring
      ctx.strokeStyle = '#334155';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(centerX, centerY, BOARD_RADIUS - Math.max(24, Math.floor(BOARD_RADIUS * 0.18)), 0, Math.PI * 2);
      ctx.stroke();
      
      // Draw center circle (Start button)
      const gradient = ctx.createRadialGradient(centerX, centerY, 4, centerX, centerY, CENTER_RADIUS);
      gradient.addColorStop(0, gameState.gameActive ? '#1f2937' : '#0ea5e9');
      gradient.addColorStop(1, gameState.gameActive ? '#111827' : '#0369a1');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(centerX, centerY, CENTER_RADIUS, 0, Math.PI * 2);
      ctx.fill();
      ctx.lineWidth = 3;
      ctx.strokeStyle = gameState.gameActive ? '#334155' : '#38bdf8';
      ctx.stroke();

      // Center text
      ctx.fillStyle = '#e2e8f0';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = `${Math.floor(CENTER_RADIUS * 0.6)}px Arial Black`;
      ctx.fillText(gameState.gameActive ? 'GO!' : 'START', centerX, centerY);
      
      // Instructions (top-left) before START
      // Desktop: detailed how-to
      if (!gameState.gameActive && !isMobile) {
        ctx.save();
        ctx.globalAlpha = 0.7;
        ctx.fillStyle = '#cbd5e1';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        const base = Math.floor(Math.min(cssW, cssH) * 0.022);
        ctx.font = `${base}px Segoe UI, Arial`;
        const lines = [
          'How to play LexiOrbit',
          '• Click START.',
          '• For the shown category, click letters for which you can name a word that belongs to the category and starts with that letter.',
          '• You have 10 seconds each turn to claim a new, unused letter.',
          '• The game ends when you claim all 20 letters or time expires.',
          '• Score = claimed letters / total available for the category (max 20).'
        ];
        const left = 24, top = isMobile ? 6 : 24;
        lines.forEach((t, i) => ctx.fillText(t, left, top + i * (base * 1.26)));
        ctx.restore();
      }
      // Mobile: brief top-left instruction per request
      if (!gameState.gameActive && isMobile) {
        ctx.save();
        ctx.globalAlpha = 0.9;
        ctx.fillStyle = '#fca5a5';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        const base = Math.max(12, Math.floor(Math.min(cssW, cssH) * 0.030));
        ctx.font = `bold ${base}px Segoe UI, Arial`;
        const left = 12, top = 10;
        const msg1 = "Click on the letter if you found a word that matches the category.";
        const msg2 = "It's a trust game, don't just click letters";
        // Wrap manually for narrow screens
        const wrap = (text, maxW) => {
          const words = text.split(' ');
          const lines = []; let line = '';
          for(const w of words){
            const test = line ? line + ' ' + w : w;
            if(ctx.measureText(test).width > maxW){ lines.push(line); line = w; }
            else line = test;
          }
          if(line) lines.push(line);
          return lines;
        };
        const maxW = Math.min(cssW * 0.82, 360);
        const lines1 = wrap(msg1, maxW);
        const lines2 = wrap(msg2, maxW);
        let y = top;
        lines1.forEach(l => { ctx.fillText(l, left, y); y += base * 1.12; });
        ctx.fillStyle = '#fca5a5';
        lines2.forEach(l => { ctx.fillText(l, left, y); y += base * 1.12; });
        ctx.restore();
      }
      
      // Draw letters
      gameState.letters.forEach((letter, index) => {
        // Uniform distribution (no global gap). Spacing comes from dynamic BOARD_RADIUS/LETTER_RADIUS above
        const count = gameState.letters.length;
        const angle = (index / count) * (Math.PI * 2) - Math.PI / 2;
        const x = centerX + Math.cos(angle) * BOARD_RADIUS;
        const y = centerY + Math.sin(angle) * BOARD_RADIUS;
        
        // Letter background circle
        const isUsed = gameState.usedLetters.has(letter);
        const isSelected = gameState.selectedLetter === letter;
        
        // Persist used letters in green; selected letter is brighter green
        ctx.fillStyle = isUsed ? '#16a34a' : isSelected ? '#10b981' : '#475569';
        // Slightly reduce radius for mobile to reduce overlap, but keep tapable via hit-test using LETTER_RADIUS
        ctx.beginPath();
        ctx.arc(x, y, LETTER_RADIUS + (isMobile ? 0 : 0), 0, Math.PI * 2);
        ctx.fill();
        
        // Letter border
        ctx.strokeStyle = isSelected ? '#34d399' : (isUsed ? '#22c55e' : '#64748b');
        ctx.lineWidth = isMobile ? 2.2 : 2;
        ctx.stroke();
        
        // Letter text (scaled with size and outlined for readability)
        ctx.fillStyle = '#e2e8f0';
        ctx.font = `bold ${Math.floor(LETTER_RADIUS * 1.08)}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        // subtle outline
        ctx.lineWidth = Math.max(1, Math.floor(LETTER_RADIUS * 0.12));
        ctx.strokeStyle = 'rgba(17,24,39,0.9)';
        ctx.strokeText(letter, x, y);
        ctx.fillText(letter, x, y);
      });
      
      // (Debug HUD removed)

      // Full-screen overlay message (e.g., Game Over)
      if (!gameState.gameActive && gameState.overlayMessage) {
        ctx.save();
        ctx.fillStyle = 'rgba(2,6,23,0.85)';
        ctx.fillRect(0, 0, cssW, cssH);
        const isGameOver = /game over|time up/i.test(gameState.overlayMessage);
        ctx.fillStyle = isGameOver ? '#ef4444' : '#e2e8f0';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const titleFactor = isMobile ? 0.09 : 0.12; // smaller on mobile to prevent spill
        ctx.font = `${Math.floor(Math.min(cssW, cssH) * titleFactor)}px Arial Black`;
        ctx.fillText(gameState.overlayMessage, centerX, centerY);
        if (gameState.overlayScoreText) {
          const scoreFactor = isMobile ? 0.048 : 0.06;
          ctx.font = `${Math.floor(Math.min(cssW, cssH) * scoreFactor)}px Segoe UI, Arial`;
          ctx.fillStyle = '#fbbf24';
          ctx.fillText(gameState.overlayScoreText, centerX, centerY + Math.min(cssW, cssH) * 0.08);
        }
        ctx.font = `${Math.floor(Math.min(cssW, cssH) * 0.04)}px Segoe UI, Arial`;
        ctx.fillStyle = '#93c5fd';
        ctx.fillText('Click START to play again', centerX, centerY + Math.min(cssW, cssH) * 0.16);
        ctx.restore();
      }

      // Top-Right: High Scores (skip on mobile for clean layout)
      if (!isMobile) {
        ctx.save();
        ctx.globalAlpha = 0.5;
        ctx.fillStyle = '#cbd5e1';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'top';
        const baseTR = Math.floor(Math.min(cssW, cssH) * 0.02);
        ctx.font = `${baseTR}px Segoe UI, Arial`;
        const header = 'Top Players';
        ctx.fillText(header, cssW - 24, 24);
        if (window.__topScores && Array.isArray(window.__topScores.top5)) {
          window.__topScores.top5.forEach((row, i) => {
            const pct = Math.round((row.avg || 0) * 100);
            const used = Math.round(row.used || 0);
            const total = Math.round(row.total || 0);
            const line = `${i+1}. ${row.player || 'Anonymous'} — ${pct}% (${used}/${total})`;
            ctx.fillText(line, cssW - 24, 24 + (i + 1) * (baseTR * 1.3));
          });
        } else {
          ctx.fillText('Loading...', cssW - 24, 24 + (baseTR * 1.3));
        }
        ctx.restore();
      }
    }

    function getLetterAt(mouseX, mouseY) {
      return gameState.letters.find((letter, index) => {
        const angle = (index / gameState.letters.length) * Math.PI * 2 - Math.PI / 2;
        const x = centerX + Math.cos(angle) * BOARD_RADIUS;
        const y = centerY + Math.sin(angle) * BOARD_RADIUS;
        
        const distance = Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2);
        return distance <= LETTER_RADIUS;
      });
    }

    function handlePointer(px, py) {
      // If not active, treat center circle as Start button
      const distToCenter = Math.hypot(px - centerX, py - centerY);
      if (!gameState.gameActive && distToCenter <= CENTER_RADIUS) {
        startRound();
        return;
      }
      if (!gameState.gameActive) return;
      const clickedLetter = getLetterAt(px, py);
      if (!clickedLetter) return;
      if (gameState.usedLetters.has(clickedLetter)) {
        showLog(`"${clickedLetter}" already used`, 'info');
        drawGame();
        return;
      }
      gameState.turnHasPressed = true;
      gameState.usedLetters.add(clickedLetter);
      gameState.selectedLetter = null;
      playSound('click');
      updateBackgroundForLetter(clickedLetter);
      drawGame();
      if (gameState.usedLetters.size === gameState.letters.length) {
        showLog('🎉 Perfect! All letters used!', 'victory');
        gameState.gameActive = false;
        const usedRaw = gameState.usedLetters.size;
        const cat = gameState.currentCategory;
        const distinct = new Set((CATEGORY_BANK[cat]||[]).map(w => w[0]?.toUpperCase())).size;
        const total = Math.min(20, distinct || gameState.letters.length);
        const used = Math.min(usedRaw, total);
        gameState.overlayMessage = 'Perfect! All letters used!';
        gameState.overlayScoreText = `Score: ${used}/${total} (${Math.round((used/total)*100)}%)`;
        backgroundWords = [];
        drawGame();
        (async ()=>{
          try{
            let player = localStorage.getItem('lexiorbit_player');
            if (!player) {
              player = 'Player-' + Math.floor(Math.random()*1e6).toString(36).toUpperCase();
              localStorage.setItem('lexiorbit_player', player);
            }
            const resp = await fetch('/api/scores', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ player, used, total })});
            const data = await resp.json().catch(()=>null);
            if (data && data.top5) { window.__topScores = { top5: data.top5 }; drawGame(); }
            else { if (typeof fetchTopScores === 'function') fetchTopScores(); }
          }catch(e){}
        })();
        return;
      }
      startNextTurn();
    }

    // Event handlers
    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      handlePointer(e.clientX - rect.left, e.clientY - rect.top);
    });
    canvas.addEventListener('touchstart', (e) => {
      if (!e.touches || e.touches.length === 0) return;
      e.preventDefault();
      const t = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      handlePointer(t.clientX - rect.left, t.clientY - rect.top);
    }, { passive: false });

    // Word input removed

    document.getElementById('newRoundBtn').addEventListener('click', () => {
      playSound('start');
      newRound();
    });

    document.getElementById('shuffleCatBtn').addEventListener('click', () => {
      playSound('click');
      shuffleCategory();
    });
    document.getElementById('voiceBtn').addEventListener('click', () => {
      if (voiceActive) { stopVoice(); } else { startVoice(); }
    });

    // submitWord removed

    function newRound() {
      gameState.usedLetters.clear();
      gameState.selectedLetter = null;
      gameState.round++;
      gameState.timeLeft = 12.0;
      gameState.gameActive = false;
      gameState.turnHasPressed = false;
      gameState.overlayMessage = '';
      backgroundWords = [];
      resetBgLayout();
      document.getElementById('roundChip').textContent = `Round ${gameState.round}`;
      // input removed
      shuffleCategory();
      drawGame();
    }

    function startRound() {
      playSound('start');
      try { if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); } catch {}
      gameState.timeLeft = 12.0;
      gameState.gameActive = true;
      gameState.turnHasPressed = false;
      gameState.overlayMessage = '';
      backgroundWords = [];
      resetBgLayout();
      document.getElementById('timer').textContent = gameState.timeLeft.toFixed(1);
      stopWarningTicker();
      drawGame();
      if (voiceActive && recognition) { try { recognition.start(); } catch {} }
    }

    function startNextTurn() {
      // Reset window for the next press
      gameState.turnHasPressed = false;
      gameState.timeLeft = 12.0;
      document.getElementById('timer').textContent = gameState.timeLeft.toFixed(1);
      stopWarningTicker();
      drawGame();
    }

    function shuffleCategory() {
      const idx = Math.floor(Math.random() * categories.length);
      gameState.currentCategory = categories[idx];
      gameState.currentCategoryIndex = idx; // 0-based
      document.getElementById('category').textContent = `${idx + 1}. ${categories[idx]}`;
      resetBgLayout();
    }

    function showLog(message, type = 'info') {
      const log = document.getElementById('log');
      log.textContent = message;
      log.style.color = type === 'success' ? '#10b981' : 
                        type === 'error' ? '#ef4444' : 
                        type === 'victory' ? '#fbbf24' : '#e2e8f0';
      
      setTimeout(() => {
        if (log.textContent === message) log.textContent = '';
      }, 3000);
    }

    // Timer (simplified for now)
    function updateTimer() {
      if (!gameState.gameActive) return;
      if (gameState.timeLeft > 0) {
        gameState.timeLeft = Math.max(0, gameState.timeLeft - 0.1);
        document.getElementById('timer').textContent = gameState.timeLeft.toFixed(1);
      }
      // Start/stop warning beeps based on remaining time in this turn (disabled in voice mode)
      if (gameState.timeLeft <= 3.0 && gameState.gameActive && !voiceActive) {
        startWarningTicker();
      } else {
        stopWarningTicker();
      }
      if (gameState.timeLeft === 0) {
        if (!gameState.turnHasPressed) {
          // No letter pressed in this 12s turn → game over
          playSound('buzz');
          showLog('⏰ Time up! Game over.', 'error');
          gameState.gameActive = false;
          const usedRaw = gameState.usedLetters.size;
          const cat = gameState.currentCategory;
          const distinct = new Set((CATEGORY_BANK[cat]||[]).map(w => w[0]?.toUpperCase())).size;
          const total = Math.min(20, distinct || gameState.letters.length);
          const used = Math.min(usedRaw, total);
          gameState.overlayMessage = 'Time Up! Game Over';
          gameState.overlayScoreText = `Score: ${used}/${total} (${Math.round((used/total)*100)}%)`;
          // Compute unused letters and update background with matching category words
          const unusedLetters = new Set(gameState.letters.filter(l => !gameState.usedLetters.has(l)));
          updateBackgroundForUnpressed(unusedLetters);
          stopWarningTicker();
          drawGame();
          // Submit score to server
          (async ()=>{
            try{
              let player = localStorage.getItem('lexiorbit_player');
              if (!player) {
                player = 'Player-' + Math.floor(Math.random()*1e6).toString(36).toUpperCase();
                localStorage.setItem('lexiorbit_player', player);
              }
              const resp = await fetch('/api/scores', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ player, used, total })});
              const data = await resp.json().catch(()=>null);
              console.log('Score submission response:', data);
              if (data && data.top5) { 
                window.__topScores = { top5: data.top5 }; 
                console.log('Updated top scores:', window.__topScores);
                drawGame(); 
              } else {
                console.log('Fallback: calling fetchTopScores');
                if (typeof fetchTopScores === 'function') fetchTopScores();
              }
            }catch(e){}
          })();
        } else {
          // Safety: if a press happened exactly at boundary and we didn't roll over yet
          stopWarningTicker();
          startNextTurn();
        }
      }
    }

    // Top scores fetcher
    async function fetchTopScores() {
      try {
        const res = await fetch('/api/scores', { cache: 'no-store' });
        const data = await res.json();
        window.__topScores = data;
        drawGame();
      } catch (e) { /* ignore */ }
    }

    // Initialize game
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    shuffleCategory();
    setInterval(updateTimer, 100);
    // kick off scores and refresh periodically
    fetchTopScores();
    setInterval(fetchTopScores, 3000);
    
    showLog('🎮 Game ready! Click START to begin.', 'info');
    console.log('Tapple game initialized successfully!');
  </script>
</body>
</html>